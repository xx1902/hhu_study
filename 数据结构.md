# <u>上课</u>

## 数据结构

**逻辑结构**

* 集合结构  同一集合
* 线性结构  一对一
  * 线性表
  * 栈和队列
  * 字符串
  * 数组
  * 广义表
* 树结构     一对多
* 网结构或网状结构   多对多



**存储结构**

* 顺序存储结构

* 链式存储结构  不要求物理地址连续



**数据类型**

* 数据类型  一个值的集合（int, float）  加上 对这组值的基本操作（加减乘除等等）
* 抽象数据类型  指用户定义的  一组操作的总称
  * 数据对象， 数据关系， 基本操作



## 算法

**特点**

* 有穷性  不是死循环
* 确定性  不会有二义性
* 可行性  不超出范围等等
* 输入  
* 输出

**优劣**

* 正确性
* 可读性
* 健壮性  当数据非法时，能做出正确反映和相应处理
* 高效性  时间 空间



**评价算法的优劣性**

* 时间复杂度

```c
// O(2n - 1)  等比数列求和  1 2 4 8 16 ... n
// 1 * (1 - 2^log n) / (1 - 2) = 2n - 1     -> O(2n - 1)
for(int i = 1; i <= n; i = i * 2)
	for(int j = 1; j <= i; j ++)
```

* 空间复杂度



## c语言

### 指针

```c
#include <stdio.h>

int main(){
    int a = 0;
    int b[3] = {1, 2, 5};
    int *p = &a;
    *p = 2; // 修改地址指向的原数值
    printf("%d\n", a); //    2
    int *f = b; // 指针指向数组地址
    int **ff = &f; // 指向地址的指针
    *ff += 2; // 数组地址加2
    printf("%d", *f); //      5
    return 0;
}
```

指针数组

int* x[10]  长度为10的数组， 每个元素都是指针



### 函数

函数类型  参数表  函数体  返回值



### 结构体



student.id

Pstudent(指针) -> id







## 线性表

线性表**特点**

* **同一性**：所有元素是同一类型
* **有穷性**：线性表由有限个数据元素组成，表长度就是表中数据元素的个数。
* **有序性**：线性表中相邻数据元素之间存在着序偶关系 <a~i~ ,  a~i+1~> 



创建线性表

* 线性表类型
* 数据元素类型
* 下标类型



线性表操作  增删改查、计数、排序



**线性表的存储**

==顺序表==    顺序存数 

* 用一组连续的内存空间、按照逻辑顺序、依次存储线性表的元素 -> 顺序表

```c
struct SeqList{
	int MaxNum; //顺序表有多长 
	int n;  //实际元素数目
	DataType * element; // 存的数据 
}

struct SeqList Var; //定义顺序表 var
typedef struct SeqList Mylist;  //Mylist类型定义
Mylist Var;
Mylist * palist;  //指向循序表的指针

palist -> MaxNum; //查询顺序表的最大空间
palist -> element[i]; // 查询第i个数据
```



操作

查找  插入  删除



==链表==   链式存储

* 用一组非连续的内存单元，分别储存，用指针表示逻辑关系、存储地址  -> 链表



**单链表**

```c
struct Node{
    DataType info;// 数据内容
    PNode link;// 指针
}
```



**循环单列表**
头指针 不存储数据 
第一个头结点 h - > link  或者 t -> link -> link

* 带头结点的单链表	
  * 判断是否为空  clist(尾结点) 是不是指向自己（尾结点和头结点是一个，头部不存储数据）

  * 加数据 尾指针向后移动  新加的数据指向头指针

* 无头结点的循环单链表	
  * 看ppt



**双向列表**

#### 双向循环列表

## 栈和队列

### 栈

特点：

* 一种特殊的线性表，插入和删除都只能在表的同一端进行
* 后进先出，先进后出

**顺序栈**  

**链栈**



### 队列

特点;

* 一种特殊的线性表，只允许在一端进行插入，而在另一端进行删除
* 先进先出，后进后出

环形队列，为了区分空和满 -> 牺牲一个节点空间

* 入队  `q.rear ++;`

* 判断是否为空  头尾指针 是否相等 ` q.front == q.rear`   front(队头在队尾后面)

* 判断是否满    尾指针+1 % 长度 是否等于头指针  `(q.rear + 1) % m == q.front`    rear(队尾在队头后面)

* 返回长度   `(尾 - 头 + m) % m`



链式队列

入队 

* 判断是否为空  空直接加
* 不为空 尾指针指向p
* 更新尾指针

头指针或者尾指针为空  队列为空



**递归**

要素

* 递归模式

* 递归出口



**稀疏矩阵**

存行和列 + 数据





## 树和二叉树

### 特点

树：前驱唯一，后继可能不唯一

结点的度：一个节点的分支个数

**满二叉树**

* 国外  度为2 或为0

* 国内定义 全满

**完全二叉树**

* 最后一层节点都集中在该层的最左边若干位置
* 特点
  * 叶子结点只可能在层次==最大的两层==上出现
  * 如果右节点的层次是l，左节点的层次是l或者l+1


**结点的平衡因子**

* 该结点左，右子树深度之差

**平衡二叉树**

* 所有平衡因子的绝对值都不大于1



**重要性质**

* 第i层至多有2^i-1^个节点
* 深度为k的二叉树至多至多有2^k^ - 1个节点
* 二叉树终端结点为n~0~ 度为2的节点数位n~2~  则==n~0~ = n~2~ + 1==
  * n = n0 + n1 + n2       从节点本身算
  * n = n1 + 2 * n2 + 1   从结点的子节点出发，再加上根节点

* 具有n个节点的完全二叉树的深度为log~2~n + 1



[入栈顺序](https://blog.csdn.net/akenseren/article/details/82149145)次数为n，相应的出栈顺序可以为  ==C^n^~2n~ / (n + 1)==





### **二叉树的遍历**

* 先序遍历
* 中序遍历
* 后序遍历 



**深度优先序列DFS**

栈结构

**非递归算法**   **先根遍历 **

**出栈序列**

* 根节点入栈
* top = 栈顶
  * 若top 非空，记录栈顶元素（输出），弹出栈顶
  * 将top 右 左 孩子进栈（反向先右后左） 
* 重复 2 直至栈空

**指针指向序列**

* 根节点入栈，p指向根节点
* p不为null
  * p进栈，p指向左孩子
* 当栈不空 
  * p 指向右孩子
  * 弹出栈顶（输出），重复2
* 若栈空且p为null， 结束





**广度优先序列BFS**

队列结构

非递归算法

* 根节点进队
* 队不空，访问队头
  * 队头的非空左，右孩子进队
  * 队头出队（输出队头）
* 重复2，直至队空





### 二叉树的实现

**顺序存储**

* 浪费空间
* 适合完全二叉树

**链式存储**





**中序线索二叉树**

* 怎么找前驱
  * 若p->ltag ==1 
    * 前驱为 p -> llink
  * 若p->ltag == 0 p有左子树   找左子树的最右下角
    * 置p=p->llink
    * 重复p=p->rlink，直到 p->rtag==1
* 怎么找后继
  * 若 p-> rtag ==1
    * 后继为 p-> rlink
  * 若p -> rtag ==0 p有右子树  找右子树的最左下角
    * 置 p=p->rlink
    * 重复p=p->llink 直到p->rtag==1;
* 怎么遍历
  * 找中序的第一个节点
  * 访问后继节点
  * 直至后继。。。



### 哈夫曼树

特点:

* 权值越大，离根越近



## 字典

### 顺序表实现

**平均查找长度 ALS**

二分查找  递归 非递归 都会写



### 散列表

函数

如何解决冲突

* 开地址法   向后探查  h=(h+d)%m
* 拉链法 



负载因子 a>0.5  空间占有率大于0.5



* 除余法





### **二叉排序树**

性质：

* 若左子树不空，左子树上所有节点的值均小于它的根节点的值
* 若右子树不空，右子树上所有节点的值均大于它的根节点的值
* 它的左右字数也分别是二叉排序树

删除 

* 叶子节点 直接删除
* 只有一个子树  子树替代父亲
* 有两个子树   子树合并
  * 如果左子树 的 右下角 是父亲的左子树  ==特判==



在二叉树中，==有两个孩子的结点==，其中序后继无左孩子，中序前驱无右孩子



**平衡二叉树（AVL树）**

*  每个结点的左右字数高度之差的绝对值不超过1
*  结点的平衡因子:右子树高度-左子树高度

最小不平衡子树

* 在新插入结点的祖先中，离新结点最近，且平衡因子绝对值>1

四种调整平衡模式

* -- LL型：新结点插入到A的左子树的左子树中；
  * 先修改父亲节点指针
* -- LR型： …………………..左…...的右…...中；
  * LRL
  * LRR
  * LR0
* -- RR型：…………………..右…...的右……中；
* -- RL型：…………………...右…...的左……中；



### B树

**b-树**

特点

* 每个结点至多有m棵子树，m-1个关键码
* 若根不是叶子，至少有两棵子树（由底层分裂生长）
* 除根，至少有m/2（向上取整）个子树，(m/2) - 1个关键码
* 所有的叶子在同一层 -> 是平衡的



**b+树**

* b-树 关键码不重复
* b+树叶子节点包含完整的关键码

* 操作都在叶子节点进行





## 图

### 概念

无向图  (A,D)

有向图 <A,D>



顶点间 邻接

顶点和边 关联



**简单图** -> 不存在重复边，不考虑自环

**完全图** -> 任意两个顶点之间都有一条边



**有根图** ->  一个顶点V可以到达所有的顶点

**连通图** -> 任意两个顶点都连通

连通分量  极大连通子图

强连通图  强连通分量

带权图



### 图的表示

邻接矩阵

邻接表







### 最小生成树

**prime算法**

> 普里姆算法其实就是结点优先算法，从图中==任意一个结点==开始，每次都找一个==权值最小的边==，将这两个结点连接起来，然后在生成的**新整体**中继续找一个权值最小的边，将新整体和最小边的终点连接起来，以此往复，直到所有的结点全部被包含进来。

**kruskal算法**

* 一直选最小的边长，直至所有点都连起来

### 最短路径

### dijkstra算法

> 假设所有边的权重都 > 0
>
> 按照长度递增的次序产生v0到各顶点的最短路径



### 拓扑排序







## 排序

### 插入排序

基本思路：每1步(趟)：将1个待排序记录，按排序码大小，插入到“已经排好序”的序列中

#### 直接插入排序

--“已排序”码  从右向左，依次 

* 若比 k~i~大，则直接后移

* 若== or < k~i~则停止移动，k~i~放入空位置

适用于：n值较小，且基本有序



#### 二分插入排序

相比于直接插入排序

* key的比较次数？

   -- 改善，总比较次数 ≈ nlog~2~n

* record移动（赋值）次数？

   -- 没有改善，*O*(n^2^)



#### 希尔排序

（缩小增量法）

  -- n个记录，增量为d**i**，则分组

   下标 0,  d**i**,    2d**i**,    3d**i**,    **……** 为1组

   下标 1,  d**i** +1,  2d**i** +1,  3d**i** +1, **……** 为1组

   下标 2,  d**i** +2,  2d**i** +2,  3d**i** +2, **……** 为1组

​    ……  ……  ……  ……

​    下标 d**i**-1,  d**i**+d**i** -1,  2d**i**+d**i** -1, **……** 为1组



* 增量为d~i~时，在各组内，进行 排序

* 减小增量，重新分组，组内 排序

* 重复2， 直到d~i~==1，所有记录在同一组，组内 排序

**不稳定**



### 选择排序

#### 简单选择排序

-- 每1步(趟)：从待排序记录中，选出最小排序码顺序放在“已排序记录”之后；

简单选择排序，每次选出1个最小值，但，每次都**“重新”**开始选择

#### 堆排序

1. 将待排序数据 建立成大根堆；
2. 重复：选出最大值（堆顶）、并调整剩余部分

一棵完全二叉树，且满足**堆序性**：

* 根最小--小根堆
* 根最大--大根堆

-- 堆的存储方式：顺序存储

​	完全二叉树的性质：按”从上到下，从左到右”将结点从0开始编号，则：父亲与左、右孩子的编号之间满足一定规律。



**建立大根堆**

* 先，将待排序记录建成1个完全二叉树，再“从后向前”依次调整
* 按“不断插入新元素”方法，向空 ”大根堆” 中，逐个插入待排序记录



方法1：先，将待排序记录建成1个完全二叉树，再**“从后向前”**依次调整(sift)

1. 判断“待调整 x”是否 **>**左孩子 && **>**右孩子

  -- 1.1 是，则无需调整，结束

  -- 1.2. 否，继续“调整 x”，即：重复1，直到x与孩子满足堆序性，或 x成为叶子



2. 排序、调整

   2.1 取出 最大值(堆顶)，将其 放入 排序序列

   2.2 调整剩余结点  - >堆

   交换：堆顶 <- -> 最后元素

​		调整堆顶，即sift(0)

**时间复杂度**

1.建堆 ->*O*(n)

2.排序、调整

​        每一趟调整 -> 树高，即*O*(logn)

​        共调整n-1趟。

   ->  O(*n*log*n*) 



### 交换排序

将待排序码，两两比较，交换不满足“顺序要求”的“偶对”，直到全部满足。

#### 冒泡排序

通过相邻记录的比较，使得：较大的记录，向右移动

从而：待排序组内最大记录，靠最右

注意：==发生时  不交换

平均时间复杂度：*O*(n^2^)

冒泡排序中，相邻记录比较，若逆序，则交换  -> 但，1次交换，只能消除1个逆序 

#### 快速排序

能否，交换不相邻的记录 -> 1次消除多个逆序？  快速排序（分区交换排序）

* 从待排序码中，选出1个k（如R~0~.key ）

* 将 小于k的记录移动到左边（左子表），大于k的记录移动到右边（右子表），

* 将k 放在“左、右两个子表”的分界处

-> 为此趟的分区基准k，找到了最终位置

  -- 最好情况

​		每1趟，“待排序列”-> 等长的两个子表

​		-> 总比较次数：C(n) ≤ n+2C(n/2) ≤ **…** ≈*O*(nlog**2**n)

 -- 最坏情况

   待排序记录，已排好序 -> 左or右子表长度为0

  -> 总比较次数：C**max**=(n-1)+(n-2)+…+1 ≈O(n**2**)



### 分配排序

  -- 将排序码，分解 ->若干部分，

   如：十位、个位

  -- 对各部分，分别排序

适用于

​	-- 字符串、整数等，

   具有明显结构特征的排序码



### 基数排序

**时间复杂度分析**

  -- 设基数：r，排序码位数：d，排序码个数：n

​    -> 共需执行  d  次“分配+收集”

  -- 每1趟基数排序

​    ->  分配的时间复杂度：O(n)

​    ->  收集的时间复杂度：O(r)

时间复杂度: *O*(d **×**(n+r))

**空间复杂度分析**

  -- 设基数：r，排序码位数：d，排序码个数：n

1. 链接存储，每个记录，增加1个指针

​    -> *O*(n)

2. 所有链式队列的头、尾指针，放在数组Q中

​    -> *O*(r)

空间复杂度:*O*(n+r)



# 期中考试

## 绪论

> 计算机中存储的、具有一定逻辑 关系和行为特征的一组数据

数据类型

* int,等
* 抽象数据类型  有一定行为的抽象类型

数据结构

* 集合
* 线性  线性表，字符串，栈，队列
* 树
* 图

算法

* 有穷性
* 确定性
* 可行性

算法性能

* 时间复杂度
* 空间复杂度

指针

* 传值调用
* 传址调用
* 引用调用



## **线性表**

* 特点
  * 同一性
  * 有序性
  * 有穷性
* 存储
  * 顺序表
  * 链表

**平均查找长度ASL**

$\sum_{i=1}^{n}p_{i}C_{i}$

* pi是查找第i个元素的概率
* 



**顺序表操作**

```c++
struct SeqList{
    int MaxNum;
    int n;
    int* element;
};
```

* 创建空链表
  * 分配空间
  * MaxNum = m
  * n = 0
* 判断表空
  * n == 0 
* 查找元素
  * 遍历 n
* 插入元素
  * 判断表是否还**有空位**
  * 判断下标是否**合法**    p<0    p>n
  * 将第p个元素及之后的 ==从后往前== 往后移动
  * 插入数值
  * ==更新表长== n

* 删除元素
  * 判断下标是否合法  p < 0 || p > palist->n-1
  * p点  ==从前往后== 往前移动
  * 更新表长 n



优点：

1. 存储**密度高**：数据本身所占空间/结点空间；
2. 方便随机存取表中任一元素； （）**访问方便**

缺点：

1. 插入或删除，需依次**移动大量**元素；
2. **预先分配**存储空间 
   1. 可能溢出，
   2. 空间可能长期闲置；





**链表**

> 在数据之外，附加指针，指示逻辑关系、存储地址

```c++
struct Node{
    int info;
    Node* link;
};
```

* 创建空链表
  * llist->link = NULL
* 判断表空
  * llist->link == NULL
* 查找元素
  * p -> info != x
  * 遍历 p = p->link
* 插入元素
  * 申请新节点q  给值
  * q的后继指向要插入p的后继
  * p的后继指向q
* 寻找前驱
  * p1->link != p;
  * 遍历 p1 = p1->link
* 删除元素
  * 找到p的前驱p1
  * p1指向p的后继



优点：

1. **插入或删除**，只需修改指针，无需移动元素；
2. 动态分配存储空间；

缺点：

1. **存储密度**比顺序表低；
2. 不能**随机访问**第i个元素，需顺链查找；





**循环单链表**

>单链表中‘尾结点的指针域’指向头结点 -> 循环单链表
>
>在逻辑上，具有“向前查找”的功能
>
>带头结点  --  不带头结点

```c++
struct Node{
    int info;
    Node* link;
};
```

* 判断尾指针 p->link == clist
* 创建空表
  * 创建节点 指向自己  clist->link = clist
* 判断表是否为空
  * llist->link == clist
* 带头结点 插入节点（尾插）  头结点H
  * 创建新节点p 给值
  * 新节点加入链表  p->link = click->link    （将最后的指针指到开头）
  * 连成环 clist ->link = p
  * ==设置尾指针==  clist = p
* 无头节点 插入节点（空表）   不是空表后和带头结点操作相同  clist指向尾结点
  * 创建新节点p 给值
  * clist = p  
  * clist -> link = clist  设置循环



**双链表**

> p为了方便查找前驱、后继 -> 双链表    -- 增加指向“前驱”的指针域L

```c++
struct DoubleNode{
    int info;
    DoubleNode* llink;
    DoubleNode* rlink;
};

typedef struct DoubleNode * PDoubleNode; 
struct DoubleList //双链表类型
{ 
    PDoubleNode head;
    PDoubleNode rear; 
};
```

* 删除节点p
  * p的前驱的rlink指向p的后继  p->llink->rlink = p->rlink
  * p的后继的llink指向p的前驱  p->rlink->llink = p->llink
* 插入节点q 在后面   （在前面逻辑相同）
  * 创建新节点q 给值
  * 新节点q的后继 指向p的后继   q->rinlk = p->rlink
  * 新节点q的前驱 指向p             q->llink = p
  * p后继的前驱指向 新节点q      p->rlink->llink = q
  * p的后继指向新节点 	           p->rlink = q





**循环双链表**

> 带头结点    --- 不带头结点

* 循环双链表性质: (p指向任意结点)
  * p == p->rlink->llink 且 p == p->llink->rlink





**Josephus问题  约瑟夫**

1) n个人围坐在一个圆桌周围，
2) 第s个人报1，依次报数，数到m的人出列，
3) 出列者的下一位报1，同理，数到m的人出列，
4) 重复3)，直到所有人都出列；

复杂度

* 顺序表
  * 按序号随机存取，*O*(1)
  * 删除结点，需移动其后续元素，*O*(n)
  * 最后1个与第1个元素“逻辑相邻”。下标 j 对“数组长度” 取余，即j=(j+1)%n，实现循环。
  * 步骤
    * 初始化顺序表：建空表，并插入n个结点；表长n、起始数的下标 s1 = s - 1、步长m；
    * 将要出列元素temp的下标：==t=(s1+m-1) %n== ；
    * 删除temp à新的顺序表，==新表长n=n-1==，  ->  用循环代替
    * 新表==是否为空==? 是则完成；否则，新的起始数数下标 ==s1= t== ;  返回2)；

* 链表
  * 按序号m查找 -- 从链首开始遍历，*O*(m)
  * 删除结点，只需修改指针，*O*(1)
  * 需知道被删除结点的前驱
  * 步骤
    * 建立, 并初始化循环单链表clist;
    * 依据s，”计数查找” 起始结点p及其前驱pre;
    * 链表中==是否仅剩1个==结点?  是，则删除该**结点**，退出;
    * 从p开始, “计数查找”第m个结点p及其前驱pre;
    * 从链表中删除p指向的结点， p指向被删结点的下一个结点；返回3)继续，





## 栈和队列

> 操作位置受限的线性表；  -- 插入、删除位置受限；

### **栈**

>p一种特殊的线性表，插入和删除都只能在表的**同一端**进行

特点

* 先进后出， 后进先出



**顺序表**

```c++
struct SeqStack{  
    int MaxNum;  
    int top;    //栈顶元素的下标，top<=MaxNum-1
    int* s;     //s指向顺序栈的第1个单元
};
typedef struct SeqSack * PSeqStack; //顺序栈的指针类型
```

* 创建空栈
  * 分配空间
  * MaxNum = m
  * top = -1
* 判断是否为空
  * pastack -> top == -1
* 进栈 push
  * 先top增加        pastack->top = pastack->top + 1
  * 给栈顶赋值
* 出栈 pop
  * 直接修改top   pastack->top = pastack->top - 1
* 取栈顶元素
  * 先==判空== 
  * 取元素 return pastack->s[pastack->top]



**顺序栈的共享技术**

* 为每个新栈，预先申请MaxNum个空间 -> 可能，空间浪费
* (两个)顺序栈的共享技术： 利用“**栈底不变，而栈顶动态变化**”的特性
* ->  两个栈，共享一维数组S[M]，两个栈的栈底，分在S的两端, 下标为0, M-1

```c++
struct dseqstack{
    int MaxNum; 
    int top[2]; 
    int* s; 
}; 
typedef struct dseqstack* PdSeqStack; 

```

* 建空栈
  * 分配空间
  * MaxNum = m
  * pstack->top[0] = -1；
  * pstack->top[1] = M;

* 进栈
* 出栈
  * 一个是top--
  * 一个是top++



**链栈**

```c++
struct Node{
    int info;
    Node* link;
};
typedef struct Node * PNode;


struct LinkStack //链栈类型定义
{ 
    Node* top; 
};
typedef struct LinkStack * PLinkStack;
//强调栈顶top是栈的一个属性
```

* 创建空栈
  * 分配空间 
  * plstack -> top = NULL
* 判断栈是否为空
  * plstack -> top == NULL
* 进栈
  * 创建新节点 给值
  * 将==新节点指向之栈顶==p->link = plstack->top
  * ==指向新栈顶==   plstack -> top = p 
* 出栈
  * 先==判空==
  * 指向栈顶  p = plstack->top 
  * 删除栈顶  ==将top指向栈顶的下一个节点==   plstack->top = plstack->top->link
* 取栈顶元素
  * 判空
  * return plstack->top->info



**栈的应用**

**1.栈与数制转换**

> 数制转换：将十进制数N转换为m进制数
>
> 
>
> 第1次mod求出最低位,而一般要求从高位输出,
>
> 即，先进后出 -> 栈

```c++
   void conversion(int N, int m)
   { Pstack S = createEmptyStack();
      while(N) { push_stack(S, N%m); ////余数进栈
                       N=N/m; } // 整除
       while( ! isEmptyStack(S)) ////当栈不空
                   { printf(“%d”, top_stack(S));
                     pop_stack(S);}
    }
```

**2.栈与括号匹配(纠错)**

> 表达式中有三种括号(), [ ], { }，检查三种括号   层层嵌套正确与否？
>
> 正确的特征：从左向右遍历，若碰到右括号，
>
> ​           则一定已经历与其配对的左括号；
>
> ​           且走到最后，左括号不多余；

步骤

* 创建空栈
* 左括号 入栈
* 右括号
  * 栈空  -> 不合法
  * 匹配栈顶  -> 弹出栈顶
  * 不匹配栈顶  -> 不合法
* 读取完
  * 栈不空 -> 不合法（左括号多余）
  * 空 ->合法

**3.栈与表达式计算**

> 计算带括号的算术表达式，并假设：
>
> 1)加、减、乘、除 4种运算符
>
> 2)操作数为int型常数
>
> 3)界定符包含： 括号 和 表达式结束符#

运算规则：

1) 先乘除、后加减
2) 从左算到右
3) 先括号内，后括号外

步骤

* 建两个栈    一个数栈   一个符号栈
* 读入字符
  * 操作数   进数栈
  * 运算符   与栈顶比较优先级
    * 新运算符的 优先级更高   -> 入栈
    * 新运算符的 优先级低  
      * 运算符出栈
      * 数栈 出栈两次   计算
      * 将结果 压入数栈
      * 继续比较（）
    * 优先级相等   计算
    * 有括号 
      * （  不动
      *  ） 算到左括号





### **队列**

> 一种特殊的线性表，只允许在一端进行插入，而在另一端进行删除

特点

* 先进先出，后进后出



**顺序队列**

```c++
struct SeqQueue{  
    int MaxNum;  
    int f, r;  //f:队列头, r:实际队尾的下一个位置
    int * q;  //q指向队列数组 
};
typedef struct SeqQueue * PSeqQueue;//PSeqQueue: 顺序队列指针类型
```

创建空队列

* 申请队列数组空间

* 右端点是 0 paq->r = 0
* 队列没元素 （左端点等于右端点） paq->f=paq->r

假溢出  ->   数组前面没有数据



**循环队列**

>-- (逻辑上)规定：
>
>paq->q[0]是paq->q[M-1]的下一个元素

会导致paq->r == paq->f    即，==队满与队空混淆==

为了区分空和满   ->  牺牲1个节点空间，

当队列中==有M-1个元素==即队满，

* 队满的条件：(paq->r+1) %M == paq->f，==（记得模M）==

* 空队的条件仍是：paq->r==paq->f

**操作**

* 创建空队列
  * 申请空间
  * MaxNum = m
  * paq->r=0, paq->f=0
* 判空 
  * paq->r == paq->f
* 判满
  * (paq->r+1) %M == paq->f
* 入队
  * ==先判满==
  * 在 r 处插入值 paq->q[paq->r] = x
  * 将r 后移  paq->r = (paq->r + 1) % M    ==注意模M==(下标做加法均要%M)
* 出队
  * ==判空==
  * ==将f 后移== paq->f = (paq>f + 1) % M
* 取队头元素
  * 判空
  * 返回队头  paq->q[paq->f]



**链表队列**

```c++
struct Node;
typedef struct Node * PNode;
struct Node
{  int  info;
   PNode  link;
};

struct LinkQueue{//链式队列类型
    PNode f; //头指针：指向队头
    PNode r; //尾指针：指向队尾 
};
typedef struct LinkQueue * PLinkQueue;
PLinkQueue plq; //plp: 指向链式队列的指针
```

* 创建空链式队列
  * 申请空间
  * 队头 ，队尾 设置为空   plq -> f = NULL,   plq -> r = NULL
* 判断队列是否为空
  * plq -> f == NULL,   plq -> r == NULL
* 入队（队尾插入）
  * 创建新节点  给值
  * ==判断队头 是否有值==
    * 没值  指向新节点（空队） plq->f = p
    * 有值  将==尾指针指向新节点==   pld->r->link=p
  * 修改尾指针 pld->r = p
* 删除队头
  * 判空
  * 将p赋值 为队头 p=plq->f
  * 删除队头 
    * ==如果只有一个节点==  都删除
    * 不止一个  pdq->f = p->link
* 取队头元素
  * 判空
  * return plq->f->info



**应用**

**打印杨辉三角**

* 用第n行计算第n+1行，

* 1个数，用完即出队；

* 新数出现就入队



### **递归和稀疏矩阵**

**递归**

> 是指在定义自身的同时，又出现了对自身的调用。 
>
>   --直接递归: 函数在其定义体内直接调用自己；
>
>   --间接递归: 函数经过一系列的中间调用语句， 通过其它函数间接调用自己；

**应用**

**1.阶乘问题**

```c++
 long fact(long n)
 { if (n == 0)
       return 1;
   else
       return n * fact(n-1);
  }
```

**2.汉诺塔问题**

```c++
void Hanoi( n, A, B, C) //将n个盘子从A移动到C

{  if (n == 1) // 递归出口
       Move(A, C); 
   else
   {   Hanoi(n-1, A, C, B);  // 如果有多个  先将上面的n-1个暂时移动到B
       Move(A, C);             // 将A上的剩下的最大的一个移动到C
       Hanoi(n-1, B, A, C); // 将B上的递归移动到C
    }
}
```





**稀疏矩阵**

> • 定义：设m×n的矩阵A中有k个非零元素，
>
> ​       又设k远小于m×n（记为k<< m×n ），  
>
> ​        则称A为稀疏矩阵

三元组表示法

* 按先行后列下标升序，存放在数组中

```c++
struct triMatrix
{   int m, n;  //行数，列数
    int k;       //非0个数 
    struct Tridata * ele; //三元组
};

struct Tridata
{   int row, col;  //行，列下标
    int value; //值
};
```

**打印原始矩阵**

```c++
//打印原始矩阵
int main(){
    struct triMatrix Ma;
    int index=0;  //三元组tri上的游历下标
    for(int i = 0; i < Ma.m; i ++){
        for(int j = 0; j < Ma.n; j ++){   
            if(i == Ma.ele[index].row && j == Ma.ele[index].col)
                printf("%d", Ma.ele[ index++].value);
            else    printf("%d", 0);
        }
    }

    return 0;
}
```

**转置**

不是简单的对调行和列的数  ->  ==要有顺序==

* 扫描1遍三元组数组，得到原矩阵M中的1列；
  * 例：找第0列，转为第0行；
  *   找第1列，转为第1行；
  * ……
  * 找第n-1列，…第n-1行；

* 外层for，i<n列
* 内层for，j<length(Ma)
* 用于寻找第i列

```c++
index=0; //Mb中的游历下标
for(i=0; i<Ma.n; i++)
{    for(j=0; j<Ma.k; j++) //数组长度Ma.k
      {    if ( Ma.ele[j].col == i ) //寻找第i列
            {   Mb.ele[index].row = Ma.ele[j].col;
                 Mb.ele[index].col = Ma.ele[j].row;
                 Mb.ele[index++].value = Ma.ele[j].value;
            }
      }
      if(index >=Ma.k)   break; //若Mb已填满，则结束
}
```







## 二叉树与树

>  树型结构：唯一前驱，后继可以不唯一



### **二叉树**

> • 结点的度：一个结点的分枝个数；
>
> • 父亲结点：存在分枝的结点；
>
> • 子结点(儿子结点)：由分枝而产生的结点；

定义

* 有限个、有层次分枝关系的结点组成的集合；   ==可以是空集==。

非空二叉树（递归定义）

* 一个根结点，及其两棵互不相交的子树
* 左子树、右子树都是二叉树；

特点

* ==除树根结点==外，所有结点只有1个前驱；
* 任何结点的后继≤ 2个；
* 二叉树的深度或高度
  * 算路径长度   ->  节点数-1
  * **根节点是第0层**
  * 从树根R到K的路径：R, A, C, G, K，长度为4。

**性质**

* 设二叉树的层数编号从0开始，则非空二叉树的i层上，至多有$2^i$个结点

* 高度为k的二叉树

  * 最多有$2^{k+1}-1$个结点(k≥0)
  * 最少有k+1个结点

* 任何非空二叉树，设有叶子结点(度为0)n0个、 度为1的结点n1个、度为2的结点n2个

  * ==n2= n0 -1==    分别从节点数 和 边数-> 边数+1=节点数

* 有n个结点的完全二叉树，其高度k为  log2n（下取整）

* 有n ≥1个结点的二叉树，其高度(深度)

  - 最大值(结点最大度为1)：n-1

  - 最小值(设计成完全二叉树)：log2n 下取整



**特殊的二叉树**

**满二叉树**

定义

* 国际定义
  * 任意结点，要么度为0，要么度为2；
  * 即：结点或者是叶子，或者有两棵非空子树
* 国内定义   **(国内考试)**
  * p除最后一层无子结点外，每层上的任意结点都有两个子结点；
  * 即：除叶子外, 其他结点都有2个孩子，且叶子结点都在最后一层；
  * 若二叉树高度(深度)k一定，结点最多的二叉树是满二叉树， ==结点数目==：$2^{k+1}-1$



**完全二叉树**

* 只允许==最后两层结点==的度数小于2；
  * 最后一层 依旧都是0（叶子节点）
  * 倒数第二层 可能为 0 1 2  （可能存在叶子节点）
* 最后一层结点都集中在该层==最左边==的若干位置
* 完全二叉树、满二叉树的==结点序号一一对应==



**扩充二叉树**

* 将二叉树的所有结点，都扩充成度为2的分枝结点
  * 原来度为0，-> 增加2个分枝、2个新结点；
  * 原来度为1，-> 增加1个分枝、1个新结点；
  * 原来度为2，-> 保持；
* 扩充二叉树中，所有叶子都是外部结点
  * 内部结点：原有结点；
  * 外部结点：新增结点；
* 外部路径长度**E**：
  * 从根到每个外部结点的路径长度之和；
*  内部路径长度**I**：
  * 从根到每个内部结点的路径长度之和；



**平衡二叉树**

* 结点的**平衡因子**：该结点的左、右子树深度之差；
* 所有结点平衡因子的绝对值都不大于1；
* 递归定义
  * 是一棵空树
  * 左右子树都是平衡二叉树，并且，左、右子树高度差的绝对值不大于1





**二叉树的遍历**

深度优先遍历

* 先序 DLR
  * 递归过程： 
    * (1) 访问根；
    * (2) 按“先根”遍历左子树；
    * (3) 按“先根”遍历右子树；
* 中序 LDR
* 后序 LRD



**反推二叉树**

* -- 递归过程：

  (1) 在后根序列中找根(最右为根)；

  (2) 在中根序列中，

     根的左侧为其左子树，右侧为其右子树

* -- 递归过程：

  (1) 在后根序列中找根(最右为根)；

  (2) 在中根序列中，

     根的左侧为其左子树，右侧为其右子树；





**非递归遍历二叉树**

**先根递归**

(1) 访问根；

(2) “先根”遍历左子树；

(3) “先根”遍历右子树；

访问根之后，不能‘忘记’根；交代‘左、右子树’之后，才能‘忘记’；



**栈实现 出栈访问**

* 根结点，入栈1次，
* 访问栈顶、退栈，并让被访问结点的==右、左孩子进栈==；注意先右后左
  * top非空
* 重复2，直到栈空

**栈实现 入栈访问**

* 置树根为当前结点p, 
* 若p≠Null，==访问p==，p进栈，p=p的左孩子；
* 重复2), 直到p为Null；
* 当栈不空，p=栈顶的右孩子， ==栈顶退栈==，返回2)；
* 若栈空且p为Null ，结束。



**中跟遍历**

* 置树根为当前结点p，
* 若p≠Null， p进栈，p=p的左孩子；
* 重复2)，直到p为Null；
* 当栈不空，p=栈顶的右孩子，==访问栈顶==，退栈，返回2)；
* 若栈空且p为Null ，结束



**后跟遍历**

* p指向树根，

* 若p≠Null,  p进栈，p=p的左孩子；
* 重复2),直到p为Null；
* 当栈不空，求助栈顶，==即p=栈顶==；
  * 栈顶无右孩子，或右孩子刚被访问， -> ==访问栈顶==，退栈，令p=Null(再次求助栈顶) ==重复4）==
  * 否则，p=p的右孩子  ==重复2）==

* 若栈空且p为Null ，结束





**广度优先遍历**

**队列实现**

* 根结点进队；
* 当队不空，访问队头，
  * 队头的==非空左、右孩子==进队
  * 队头出队；
* 重复2)直到队空；

**如何判断是否为完全二叉树**

* 遍历过程中(初始化flag=0)：
* 第1次遇到leftChild或rightChild为空，置flag=1；
* 继续，若后续结点有孩子非空，且flag为1，则不是完全二叉树；





### **二叉树实现**

**顺序表示**

将完全二叉树，按‘广度优先遍历’的顺序，进行顺序存储：

基本操作：

*  求结点的左孩子、右孩子、父亲、左右兄弟；
  * ==复杂度？O(1)==

缺点：浪费空间





**链接表示**

二叉链表链表 -- **左右孩子(左右指针)表示法**：

```c++
struct BinTreeNode 
{   DataType  info; 
     PBinTreeNode  llink;     
     PBinTreeNode  rlink; }; 
typedef struct BinTreeNode * BinTree; 
```

* 创建二叉树

  * 扩充二叉树的先序序列:`ABD$$$CE$G$$FH$$I$$`
  * 若节点为空  return NULL
  * 否则 申请空间
    * 给值
    * 创建左右子树 p->llink = create_BTree();   p->rlink = create_BTree(); 

* 求叶节点数

  * 递归 算 左右子树的 叶子数

  ```c++
     int leaf(BinTree t)
         若t空，          return 0;
         若t是叶子，   return 1;
         //否则，说明t至少有一颗子树
         return(leaf(t->llink) + leaf(t->rlink) );
     }
  ```



n个结点的二叉树(二叉链表)，有几个空指针？

* ==n+1==个     2n个指针节点 - （n-1）个边



**线索二叉树**

>空的llink存储：结点在某遍历序列中的前驱；
>
>空的rlink存储：结点在某遍历序列中的后继；

中序线索，总是向上指

加入==标志位==：ltag,  rtag -> 新的结点结构

```c++
struct ThrTreeNode
 {     DataType info; 
       PThrTreeNode  llink, rlink; 
       int ltag, rtag; }
typedef struct ThrTreeNode * ThrTree; 
```

意义

* 方便寻找“中序序列”中的前驱与后继，提高遍历速度；
* 非递中序归遍历，不需要栈；

**找任意节点p的中序前驱**

* 若p->ltag==1, 

  *  前驱为：p->llink;

*  若p->ltag==0 (则p有左孩子), 

  * 前驱为：p的左子树的==“最右下”==结点；

  * 做法
    * 置p=p->llink,
    * 重复p=p->rlink，直到 p->rtag==1;
    * 进入p的左子树，沿rlink，找第1个没有右孩子的结点；

  ```c++
  if(p->ltag==1) 
        return (p->llink); 
  if(p->ltag==0)
        p=p->llink; 
        while(p->rtag==0)
               p=p->rlink; 
        return p; 
  }
  ```

**找任意结点p的中序后继**

* 同上 找最左下





### **应用**

堆

优先队列

**哈夫曼树**

> 等长编码
>
> * 码长为n à可以表示2n个不同的字符
>
> 不等长编码
>
> * 传送码长尽量短 -> 高频词汇的编码尽量短；
> * 译码结果唯一  -> 前缀编码
>   * --任一编码不是其他编码的前缀(开始部分)； 

特点

* 权值越大，离根越近；
* 带权结点是 ==叶子==（外部结点）

定义

* 将m个带权结点作为叶子，构造二叉树， 其中带权路径长度最小的为哈夫曼树

* Ø 叶子的带权路径长度：

    权值×路长：wi ×Li；

* Ø 树的带==权路径长度（WPL）==：

  		叶子带权路长之和：求和(wi ×Li)

建立

* 带权结点独立成树
* 合并根最小的两棵, 成新树 ， 新树根的权=左+右子权值
* 重复2)，直到只剩1棵树

```c++
struct HtNode
{   int ww;
     int parent, lindex, rindex;
}//哈夫曼树的结点结构
```





### 树

> 有限个结点及其关系的集合，可以为空，否则满足：
>
> (1)有且仅有1个根；
>
> (2)除根外，
>
> ​    其余结点分为若干不相交的集合
>
> ​    T1, T2, ……, Tm，
>
>    每个集合是1棵树，称为根的子树。

• 结点的度：该结点的孩子个数；

• 树的度：树中结点度的最大值；

• 兄弟：有共同的父结点；

• 无序树：兄弟间无左右次序；

• 有序树：兄弟分左右；

• 长子：最左子结点；

• 次子：长子的右邻；

• 左、右兄弟



**遍历**

先根遍历

- 访问根结点D

- 从左到右先根遍历所有子树

步骤

* -- 沿长子方向，边访问边进栈，

    走不动时（即栈顶没有孩子时），

    去栈顶的右兄弟处，栈顶退栈；

后根遍历

- 从左到右后根遍历所有子树

- 访问根结点D

步骤

* 置树根为当前结点p, 
* 当p≠Null, p进栈, p=p的长子；
  *  重复, 直到p==Null；
* 若栈不空，==访问栈顶，==
  * p=栈顶的右兄弟，
  * 栈顶退栈，返回2)；
* 若栈空且p==Null，结束。



**树的广度优先遍历**

* 根结点进队；
* 当队不空，访问队头，
  * 队头的孩子==从左至右依次进队==，
  * 队头出队；

* 重复2)直到队空；



**树的实现**

> 需反映的关系：
>
> 1. 父亲--孩子；
> 2. 左--右兄弟；

**1.父亲数组表示法**

  (双亲表示法，父指针表示法)

```c++
struct ParTreeNode
{ DataType info; //结点数据信息
   int parent;  }; //父亲的下标

struct parTree
 { int MaxNum, n;   
   struct ParTreeNode * nodelist;};
Typedef struct ParTree *PParTree; 
```

直接存储：父亲--孩子关系，

**兄弟之间的‘左右关系’，如何体现？**

* 按照某种遍历顺序，依次存放各结点。

**找p结点的右兄弟**

* 先根顺序 先判断p的值是否合法
* 右兄弟的节点比 p大     ==遍历 p+1 ~ n==
  * 直至父亲节点相同

**找p节点的长子**

* 先根顺序  一定在p的==下一位置==
* 判断下一个 结点的父节点是否为 p



**2.子表表示法 (孩子链表表示法)**

* 子表：一个结点的所有孩子、按从左至右的顺序组成1个单链表；

* 结点表：是一个顺序表，长度为n，每个元素的结构为 info 和 chlidren

可以按照先根顺序，也可以按照广度搜索

```c++
struct EdgeNode//子表(单链表)中结点结构
 { int nodePosition; 
   struct EdgeNode * link; };

struct ChiTreeNode//结点表中元素结构
 { DataType info; 
   struct EdgeNode * children;};

struct ChiTree//树的类型（顺序表结构）
{  int MaxNum;
   int root; 
   int n; 
   struct ChiTreeNode * nodelist;}
typedef struct ChiTree * PChiTree;
```

小结：（对于下标为p的结点）

* 方便找：长子、所有孩子；
* 找p的父亲？
  - 依次检查各子表，若p在其中，返回“该子表所隶属的结点表中元素”；
  - 遍历子表 i  遍历结点表 找到 return i

* 找p的右兄弟？
  - 依次检查各子表，若p在其中，则该子表中，p的下一个结点即是。
  - 遍历子表 i  遍历节点表 找到 return v->link->nodePosition



**3.长子-兄弟表示法**

* 指针 lchild指向长子
* info数据信息
* 指针 rsibling指向右兄弟

```c++
struct CSNode;
typedef  struct CSNode * PCSNode;
struct CSNode
 { Datatype info; 
   PCSNode lchild;
   PCSNode rsibling;}
```

小结：（对于指针p所指结点） 

* 找长子：p->lchild;

* 找右兄弟：p->rsibling;

* 找p的所有子结点：

  * q=p->lchild;

      while(q!=null)

      {访问q;

       q=q->rsibling;}

* 找父亲？

  * --遍历树，判断结点孩子是否是p







# 期末考试

## 查找

<img src="C:/Users/17363/AppData/Roaming/Typora/typora-user-images/image-20240627234822003.png" alt="image-20240627234822003" style="zoom:33%;" />

<img src="C:/Users/17363/AppData/Roaming/Typora/typora-user-images/image-20240628103619165.png" alt="image-20240628103619165" style="zoom:33%;" />

<img src="C:/Users/17363/AppData/Roaming/Typora/typora-user-images/image-20240628103709322.png" alt="image-20240628103709322" style="zoom:33%;" />

<img src="C:/Users/17363/AppData/Roaming/Typora/typora-user-images/image-20240628122014630.png" alt="image-20240628122014630" style="zoom: 25%;" />

<img src="C:/Users/17363/AppData/Roaming/Typora/typora-user-images/image-20240628144813735.png" alt="image-20240628144813735" style="zoom:33%;" />





### 线性表的查找

字典（查找表）  key（关键码）和 attribute（属性）

**平均查找长度ASL**

<img src="C:/Users/17363/AppData/Roaming/Typora/typora-user-images/image-20240627221638780.png" alt="image-20240627221638780" style="zoom: 33%;" />



**顺序索引**的 平均检索长度

<img src="C:/Users/17363/AppData/Roaming/Typora/typora-user-images/image-20240627221803957.png" alt="image-20240627221803957" style="zoom:25%;" />

**二分检索**（折半查找）

*  将key与”待查找表”中间位置的关键码比较，若相等，则找到；

* 否则，中间位置的某一侧作为新”待查找表”，返回1).

  <img src="C:/Users/17363/AppData/Roaming/Typora/typora-user-images/image-20240627221952062.png" alt="image-20240627221952062" style="zoom: 25%;" />

### 散列表的查找

#### 基本概念

> 已知关键码key，最小的检索长度为1，平均检索长度ASL可能是‘*O*(1)’吗？
>
> * 关键问题：
>
> 1. 散列函数 or 哈希函数 h(key)；
> 2. 若有key1 ≠ key2 且 h(key1)==h(key2)，即碰撞/冲突，怎么解决？

* 已知散列表(字典)、h()函数，检索key0：

1. 计算散列地址h(key0)，
2. 若该地址所存放为key0，则成功；否则，按”解决冲突的办法”，继续寻找……



* 散列函数的定义域：关键码的集合；

*  …值域：可用的地址空间(基本区域)；

* 负载因子： α=字典中元素的数目/基本区域的总容量

* 散列函数设计原则：

    (1) 计算简单，散列地址尽量**均匀分布**；

    (2) 少浪费空间，理想的负载因子**α>0.5**；



**除余法**

* m: 基本区域长度；

* p: 小于等于m的最大素数(质数)；
* 散列函数：h(key) = key % p 

**冲突的解决办法**

1) **基本区域内 -> 开地址法(开放地址法、闭散列)**
   1) 线性探查法：   基本区域 ->  循环表，从碰撞发生处h，**顺序向后，找第1个空位**
      1) di = 1, 2, 3, 4, 5…., m-1
   2) 二次探查法
      1) di = 1^2^, -1^2^, 2^2^, -2^2^ …., k^2^, -k^2^
   3) 伪随机探测法：伪随机数序列

<img src="C:/Users/17363/AppData/Roaming/Typora/typora-user-images/image-20240627223413215.png" alt="image-20240627223413215" style="zoom:25%;" align = "left"/>

2) **基本区域外 -> 拉链法(链地址法、开散列)**



#### 开放地址法

##### **实现查找**

<img src="C:/Users/17363/AppData/Roaming/Typora/typora-user-images/image-20240627224413251.png" alt="image-20240627224413251" style="zoom: 33%;" align = "left" />

最终退出的实现  -> ==循环M次==

```c++
int linearSearch(DE *hashT, keyType ke, int *p){
    int d = h(ke);
    for(int i = 0; i < M; i ++){        // 最多比较M次 一圈
        if(hashT[d].key == 0 || hashT[d].key == -1){          // 空位置失败
            *p = d;
            return 0;
        }
        else if(hashT[d].key == ke){    // 有值
            *p = d;                     // 找到
            return 1; 
        }
        d = (d + 1) % M;                // 不空但不等
    }
    *p = -1;  //查找一圈 没找到key 说明散列表已满
    return 0;
}
```

##### **插入**

<img src="C:/Users/17363/AppData/Roaming/Typora/typora-user-images/image-20240627230410074.png" alt="image-20240627230410074" style="zoom: 33%;" align = "left"/>

==先查找 按照查找结果插入==

```c++
int linearInsert(DE *hashT, DE ele){  // 插入  ->  先查找再插入
    int position, temp;
    temp = linearSearch(hashT, ele.key, &position);
    if(temp == 1)           // 找到相同值
        printf("ele 已经存在");
    else if(position != -1) // 没找到且 p为空位置
        // phd->element[position]=ele;
        hashT[position] = ele;
    else return 0;          // 散列表已满
    
    return 1; // 可以放在第一个if里面
}
```

##### **删除**

==需要特殊标记 key为 -1==

<img src="C:/Users/17363/AppData/Roaming/Typora/typora-user-images/image-20240627233040678.png" alt="image-20240627233040678" style="zoom:33%;" />

key == -1 表示元素已删除，

**检索**：**关键码-1不是终点, key==0才是；**

**插入**：**key为0、-1的位置都“空”，可用；**

<img src="C:/Users/17363/AppData/Roaming/Typora/typora-user-images/image-20240627233306673.png" alt="image-20240627233306673" style="zoom:33%;" />

不全对  会出现两个 32



##### 查找成功 失败的ALS

1.表中，n个元素     -> n种成功；

2.h种“除余结果”  -> h种失败；

<img src="C:/Users/17363/AppData/Roaming/Typora/typora-user-images/image-20240627233702804.png" alt="image-20240627233702804" style="zoom:33%;" />

<img src="C:/Users/17363/AppData/Roaming/Typora/typora-user-images/image-20240627233719142.png" alt="image-20240627233719142" style="zoom:33%;" />



已知n个关键码具有相同的散列值d，若采用线性探查法解决碰撞，则在散列这n个关键码的过程中，共将要发生==n(n - 1)/ 2==次碰撞



#### 拉链法

**处理碰撞**

<img src="C:/Users/17363/AppData/Roaming/Typora/typora-user-images/image-20240627234432057.png" alt="image-20240627234432057" style="zoom:33%;" />

**平均查找长度**

<img src="C:/Users/17363/AppData/Roaming/Typora/typora-user-images/image-20240627234512089.png" alt="image-20240627234512089" style="zoom:33%;" />

**小结：**

 (1) 检索、插入、删除操作都在单链表上进行；

 (2) 堆积现象可能发生吗？  不会

### 树表的查找

#### 二叉排序树

##### 基本概念

> 又称 二叉搜索树  BST

* 定义：是一颗空树，或者满足

 (1) 树根**＞**左子树上所有结点；

 (2) 树根**＜**右子树上所有结点；

 (3) 左、右子树，也是BST。



**重要性质：**

* 中序遍历二叉排序树 -> 递增序列

* 判断1棵二叉树 是否是二叉排序树？  ->  中序遍历



##### **查找性能**

<img src="C:/Users/17363/AppData/Roaming/Typora/typora-user-images/image-20240627235938116.png" alt="image-20240627235938116" style="zoom: 25%;" />

**比较次数：**

  **最坏平均查找长度**ASL：(n+1)/2

  **最好ASL**：log2(n) ，(参考二分查找)

<img src="C:/Users/17363/AppData/Roaming/Typora/typora-user-images/image-20240628105453718.png" alt="image-20240628105453718" style="zoom: 50%;" />



##### **查找**

<img src="C:/Users/17363/AppData/Roaming/Typora/typora-user-images/image-20240627235750811.png" alt="image-20240627235750811" style="zoom:33%;" />

```c++
// 递归查找
BSTree searchBST(BSTree T, keyType x){ // 返回节点  指向x的指针
    if(T == NULL || x == T -> key) return T;  // 查找成功，则返回指向x的指针，否则 返回空指针
    else if(x < T-> key)                      // 小于 搜索左子树
        return searchBST(T -> llink, x);
    else return searchBST(T -> rlink, x);     // 大于 搜索右子树
}

// 非递归查找
BSTree searchBST_2( BSTree T, keyType x){
    BSTree root, parent;
    root = T; //p指向树根
    parent = root; //后续：q用于记录p的父亲
    while(root != NULL){ // 节点不为空
        if(root->key == x) // 找到当前数
            return root;
        parent = root; // 没找到更新父亲节点
        if(x < root->key) root = root->llink; // 小于左子树
        else root = root->rlink; 
    }
    return parent; //找不到 返回父节点
}
```

成功(return 1)，则*pos非空，指向  x所在结点；

失败(return 0)，则*pos非空指向  “失败空位”的父亲；

​             特殊失败：树是空的, 则*pos==Null

```c++
int searchBST( BSTree T, KeyType x, BSTree *pos)
{   BSTree p, q;
    p = T; 
    q = p;  
    *pos = T; //废话，为了展示pos的用法
  while( p != Null) 
     if ( p->key == x)
     {    *pos = p;   return 1;  }
     q=p; 
     if( x<p->key)  p = p->llink;
     else               p = p->rlink;  
  }
  *pos = q; 
  return 0; 
}
```



##### 插入

先查找 后插入

**如果已经有相同的值 不同插入**

==注意 引用调用==

<img src="C:/Users/17363/AppData/Roaming/Typora/typora-user-images/image-20240628001843028.png" alt="image-20240628001843028" style="zoom:33%;" />

```c++
// 递归插入
void insertBST(BSTree &T, keyType x){ // 引用调用
    if(T == NULL){
        BSTree p = (BSTree)malloc(sizeof(BSTNode));
        p->key = x;
        p->llink = NULL;
        p->rlink = NULL;
        T = p; // 新结点p取代空位置*pT
    }
    else if(x < T->key) insertBST(T->llink, x);
    else                insertBST(T->rlink, x);
}
```

**非递归插入**





<img src="C:/Users/17363/AppData/Roaming/Typora/typora-user-images/image-20240628104441530.png" alt="image-20240628104441530" style="zoom:33%;" />

```c++
int insertBST( BSTree *pT, KeyType x)
{ BSTree p, posp; 
  if(searchBST(*pT, x, &posp)==1)  return 1;  // 先查找 后插入
  p=(BSTree)malloc(sizeof(…));  // 建立节点
  if(p==Null)    {printf(“error !\n”);  return 0;} //建点失败
  p->key =x;      p->llink =Null;       p->rlink =Null; 	
  if(posp==Null)      *pT = p; 					// 空 树 直接建
  if( x<posp->key)   posp->llink=p; 	// 小于 在左子树
  else                      posp->rlink=p; 
  return 1; 
}
```



##### 构造

已知关键码序列，构造二叉排序树，过程：

按关键码的先后次序，不断插入新结点；

```c++
void create(BSTree *ptree, SeqDictionary *dic){ //由顺序字典dic建二叉排序树
    *ptree = NULL;
    for(int i = 0; i < dic->n; i++) // 字典元素依次插入BST中
         if(!insertNode(ptree, dic->element[i].key) )
              return 0; //若插入失败，返回0
    return 1; //成功，返回1
}
```

##### 删除

删除1个结点p，对BST的影响范围，多大？  ->  p 及其子树

从树T中，删除结点p ( 知其父亲fp)

* 若*p是**叶子** -> 直接删除

  <img src="C:/Users/17363/AppData/Roaming/Typora/typora-user-images/image-20240628003456746.png" alt="image-20240628003456746" style="zoom:33%;" />

```c++
if ( p==T) //p是树根，则变空树
     T = null;
else if ( p==fp->llink) //是父亲的左子
             fp->llink = null;
else
             fp->rlink = null;
free(p);   
```



* 若*p **只有1个孩子** ->  孩子取代它

<img src="C:/Users/17363/AppData/Roaming/Typora/typora-user-images/image-20240628003655555.png" alt="image-20240628003655555" style="zoom:33%;" />

```c++
q=p->rlink;   // 指向非空孩子
if ( p==T)     T = q;       // p是根
else if ( p==fp->llink)  // p是左子树
 			 fp->llink = q;
else       fp->rlink = q;
free(p);  
```

* 若 *p 有2个孩子 ：

  * 法1**:**  将*p的两棵子树合并成1棵，取代*p；

    * (a)以左子树为主   

    * 将右子树放在  左子树“中序”的后面， 即，左子树的右下方

    * <img src="C:/Users/17363/AppData/Roaming/Typora/typora-user-images/image-20240628004334706.png" alt="image-20240628004334706" style="zoom: 25%;" />

    * ```c++
      s=p->llink;  // 左子树为主
      while( s->rlink!=null)  
                 s=s->rlink;  // ①找右下
      s->rlink =p->rlink; // ②合并
      fp->rlink = p->llink;  // ③取代
      ```

      有==缺陷==吗？-- 有, 树高

    * (b)同理以右子树为主  将左子树放在 右子树”中序第1元素”之前，即，右子树的左下方

  * 法2**:** *p的**中序前驱 (or后继)** s取代*p, 并删除s；

  <img src="C:/Users/17363/AppData/Roaming/Typora/typora-user-images/image-20240628004836277.png" alt="image-20240628004836277" style="zoom: 33%;" />

  * 要保留 左子树 右**下角的父节点**

    (1)“取代”：不改p相关指针， 仅复制key， p->key = s->key;

    (2)   删除s，s无右子，用s->llink取代s

    ==s的左子成为fs的右子？==  ==不一定==  特殊情况为 左子树 本身就是 最右下角

    <img src="C:/Users/17363/AppData/Roaming/Typora/typora-user-images/image-20240628005325928.png" alt="image-20240628005325928" style="zoom: 33%;" />

​		

```c++
if(p->llink && p->rlink )   // 有两个儿子
{   fs=p; //fs: s的父亲
    for( s=p->llink;  s->rlink!=null;  s=s->rlink)     // 也可以用while
           fs = s;  //1. 找p的中序前驱s, 及s的父亲fs
    p->key = s->key; //2. 复制key
 // 删除操作
    if (s==fs->llink) //或if(fs==p)  判断特殊情况
             fs->llink = s->llink; 
    else  fs->rlink = s->llink; 
    free(s);   return 1; //释放s空间
}
```

* 法2：后继同理	

<img src="C:/Users/17363/AppData/Roaming/Typora/typora-user-images/image-20240628010207029.png" alt="image-20240628010207029" style="zoom: 33%;" />

<img src="C:/Users/17363/AppData/Roaming/Typora/typora-user-images/image-20240628010218481.png" alt="image-20240628010218481" style="zoom:33%;" />

推论：在二叉树中，有两个孩子的结点，其**中序后继无左孩子**,**中序前驱无右孩子**(左子树右下角没  右孩子)





#### 平衡二叉排序树

##### 基本概念

> 假设：树上结点的检索概率相等，
>
> 为了使平均检索长度(ASL)比较短，
>
> 希望：每个结点的左、右子树“高度基本相同”

**AVL树**：每个结点的左、右子树高度之差的绝对值不超过1.

结点的平衡因子① = 右子树高度 – 左子树高度（与教材取值相反，但原理相同）

**存储结构 相较于 BST多个 bf 平衡因子**

```c++
struct  AVLNode; 
typedef  struct  AVLNode* PAVLNode;  
struct  AVLNode 
{  KeyType  key; 
   int  bf;           //平衡因子
   PAVLNode  llink, rlink; };   //左、右孩子指针
typedef  struct  AVLNode * AVLTree;
```



##### 插入新节点

* 若新结点不改变“以其父亲为根”的子树的高度 ->不破坏
* 若新结点增加了“以其父亲为根”的子树的高度 ->不一定 

最小不平衡子树？（根在哪？）

  -- 在新插入结点的祖先中，离新结点最近,  且平衡因子绝对值>1

插入前预判：**谁可能**是“最小不平衡子树” 的根？

  -- 在新结点的祖先中，离新结点最近，

>  且新结点插入之前，平衡因子绝对值>0
>
> 1. 每个结点附带bf属性
> 2. 寻找插入位置过程中，依bf，找“最近可疑点”
> 3. 判断”可疑点”失衡吗？
>
> 3.1. 若该点原bf为-1，且插入到左子树 -> 不平衡
>
> 3.2. 若该点原bf为1，且插入到右子树 -> 不平衡



##### 调整平衡的模式

<img src="C:/Users/17363/AppData/Roaming/Typora/typora-user-images/image-20240628112213401.png" alt="image-20240628112213401" style="zoom:33%;" />

* ==LL型：==新结点插入到A的左子女的左子树中  -> 不平衡

<img src="C:/Users/17363/AppData/Roaming/Typora/typora-user-images/image-20240628112317267.png" alt="image-20240628112317267" style="zoom:33%;" />

```c++
A->llink=B->rlink; 
  B->rlink=A; 
  A->bf=0;  
  B->bf=0;  
```

<img src="C:/Users/17363/AppData/Roaming/Typora/typora-user-images/image-20240628112637093.png" alt="image-20240628112637093" style="zoom:33%;" />

* ==RR型：==新结点插入到A的右子女的右子树中 -> 不平衡

<img src="C:/Users/17363/AppData/Roaming/Typora/typora-user-images/image-20240628112717827.png" alt="image-20240628112717827" style="zoom:33%;" />

```C++
A->rlink=B->llink; 
  B->llink=A; 
  A->bf=0;  
  B->bf=0; 
```

* **LR型：**新结点插入到A的左子女的右子树中 -> 不平衡
  * LRL关键语句

<img src="C:/Users/17363/AppData/Roaming/Typora/typora-user-images/image-20240628112851558.png" alt="image-20240628112851558" style="zoom:33%;" />

```c++
C=B->rlink;
  A->llink=C->rlink; 
  B->rlink=C->llink; 
  C->llink=B; 
  C->rlink=A;
  A->bf=1;  B->bf=0;  C->bf=0;   
```

* LRR关键语句

<img src="C:/Users/17363/AppData/Roaming/Typora/typora-user-images/image-20240628113614233.png" alt="image-20240628113614233" style="zoom:33%;" />

```c++
C=B->rlink;
  A->llink=C->rlink; 
  B->rlink=C->llink; 
  C->llink=B; 
  C->rlink=A;
  A->bf=0;  B->bf=-1;  C->bf=0;   
```

* LR0关键语句

  <img src="C:/Users/17363/AppData/Roaming/Typora/typora-user-images/image-20240628114559201.png" alt="image-20240628114559201" style="zoom:33%;" />

  ```c++
    C=B->rlink;  A->llink=C->rlink;  B->rlink=C->llink; 
    C->llink=B;  C->rlink=A;
    A->bf=0;  B->bf=0;  C->bf=0;   
  ```

  


##### ALV树的建立

<img src="C:/Users/17363/AppData/Roaming/Typora/typora-user-images/image-20240628120739203.png" alt="image-20240628120739203" style="zoom:33%;" />

<img src="C:/Users/17363/AppData/Roaming/Typora/typora-user-images/image-20240628121113913.png" alt="image-20240628121113913" style="zoom:33%;" />

* 找到 根节点（最小不平衡树的根）

<img src="C:/Users/17363/AppData/Roaming/Typora/typora-user-images/image-20240628121124208.png" alt="image-20240628121124208" style="zoom:33%;" />

* 判断为true的话   A -> bf = 0是必然的   因为A绝对值为1

<img src="C:/Users/17363/AppData/Roaming/Typora/typora-user-images/image-20240628121136618.png" alt="image-20240628121136618" style="zoom:33%;" />

* 判断 失衡 并调整

  <img src="C:/Users/17363/AppData/Roaming/Typora/typora-user-images/image-20240628121902636.png" alt="image-20240628121902636" style="zoom: 25%;" />



#### B树

##### 基本概念

<img src="C:/Users/17363/AppData/Roaming/Typora/typora-user-images/image-20240628142421940.png" alt="image-20240628142421940" style="zoom:33%;" />

```c++
   struct BTNode;
   typedef  struct BTNode * PBTNode;
   struct BTNode 
   {   PBTNode  parent;   
       int  keyNum;
       PBTNode * ptr;  //m个指针，m-1个关键码
       KeyType  * key; //可申请m个单元，但key[0]不使用
   }
   typedef  struct BTNode * BTree;
   typedef  BTree * PBTree;
```

##### 查找

<img src="C:/Users/17363/AppData/Roaming/Typora/typora-user-images/image-20240628143207143.png" alt="image-20240628143207143" style="zoom:33%;" />

##### 插入

**受限于   ： 每个结点至多有m棵子树、m-1个关键码**

* 先查找，在最下层寻找插入位置(结点)

 	(1) 若该结点中关键码**个数小于m-1**，则**直接插入**

 	(2) 否则，将key暂放结点中，以中间值将结点分裂为2个，并将**中间值“插入到父结点中”**

-> 从最下层开始的分裂，可能向上层“传递”

极限情况：一直分裂到根结点，并建立新的树根

<img src="C:/Users/17363/AppData/Roaming/Typora/typora-user-images/image-20240628143539478.png" alt="image-20240628143539478" style="zoom:33%;" />

<img src="C:/Users/17363/AppData/Roaming/Typora/typora-user-images/image-20240628143548492.png" alt="image-20240628143548492" style="zoom:33%;" />

<img src="C:/Users/17363/AppData/Roaming/Typora/typora-user-images/image-20240628143601931.png" alt="image-20240628143601931" style="zoom:33%;" />

<img src="C:/Users/17363/AppData/Roaming/Typora/typora-user-images/image-20240628143611540.png" alt="image-20240628143611540" style="zoom:33%;" />



##### 删除

**受限于 ： 除根外，每个分枝结点至少有m/2 上取整 棵子树；**

* 若key在最下层结点中，

​    1.1 若结点中关键码个数 >  m/2（上取整）  -1，则**直接删**

​    1.2 若结点中关键码个数== m/2 （上取整） -1，

​       	且其左or右兄弟中的关键码个数 > m/2（上取整） -1，

​       	则，左兄弟中最大or右兄弟中最小值**上移至父亲**，==（父子交换）==

​       	父结点中”大小紧邻”key的**关键码下移**，取代key

<img src="C:/Users/17363/AppData/Roaming/Typora/typora-user-images/image-20240628143933958.png" alt="image-20240628143933958" style="zoom:33%;" />

<img src="C:/Users/17363/AppData/Roaming/Typora/typora-user-images/image-20240628143944916.png" alt="image-20240628143944916" style="zoom:33%;" />

​	1.3 若结点、其兄弟的关键码个数都== **é**m/2**ù** -1，

​       	则，==(兄弟)合并==：将key删除后的剩余关键码、       

​       	父亲中的1个关键码，**合并到其左(右)兄弟中**

<img src="C:/Users/17363/AppData/Roaming/Typora/typora-user-images/image-20240628144045957.png" alt="image-20240628144045957" style="zoom:33%;" />

<img src="C:/Users/17363/AppData/Roaming/Typora/typora-user-images/image-20240628144054042.png" alt="image-20240628144054042" style="zoom:33%;" />

* 若key不在最下层，为了**“中序有序”，**

   	 用key的左子树中的最大码 or 右子树中的最小码**k**

   	 取代key，-> 从该子树中删除**k**即可(**k**一定在最下层)

包含删除叶子节点 的 父子交换等步骤

<img src="C:/Users/17363/AppData/Roaming/Typora/typora-user-images/image-20240628144550437.png" alt="image-20240628144550437" style="zoom:33%;" />

<img src="C:/Users/17363/AppData/Roaming/Typora/typora-user-images/image-20240628144609729.png" alt="image-20240628144609729" style="zoom:33%;" />

<img src="C:/Users/17363/AppData/Roaming/Typora/typora-user-images/image-20240628144620626.png" alt="image-20240628144620626" style="zoom:33%;" />



##### B+树

1. 检索，必须查找到叶子；
2. 插入、删除，都在叶子上进行

<img src="C:/Users/17363/AppData/Roaming/Typora/typora-user-images/image-20240628144755307.png" alt="image-20240628144755307" style="zoom:33%;" />



## 图

<img src="C:/Users/17363/AppData/Roaming/Typora/typora-user-images/image-20240628162825073.png" alt="image-20240628162825073" style="zoom:33%;" />

<img src="C:/Users/17363/AppData/Roaming/Typora/typora-user-images/image-20240628192500606.png" alt="image-20240628192500606" style="zoom:33%;" />

<img src="C:/Users/17363/AppData/Roaming/Typora/typora-user-images/image-20240628192512464.png" alt="image-20240628192512464" style="zoom:33%;" />

<img src="C:/Users/17363/AppData/Roaming/Typora/typora-user-images/image-20240628204136429.png" alt="image-20240628204136429" style="zoom:33%;" />

<img src="C:/Users/17363/AppData/Roaming/Typora/typora-user-images/image-20240628212009703.png" alt="image-20240628212009703" style="zoom:33%;" />

<img src="C:/Users/17363/AppData/Roaming/Typora/typora-user-images/image-20240628220314567.png" alt="image-20240628220314567" style="zoom:33%;" />

### 基本概念

* 组成：顶点集合V ，以及

​       	 定义在该集合上的关系集合E;

* 符号： G=(V, E)，

​        	图G上的顶点集合: V(G), 

​        	图G上的边(关系)的集合: E(G);



**无向图**：1条边上的2个顶点组成无序对；   **(**A, D**)** **ó** **(**D, A**)**

**有向图**：1条边(弧) 上的2个顶点组成有序对；  **<**C, D**>**：**起点C, 终点D；**



**简单图** -> 不存在重复边，不考虑自环

**完全图** -> 任意两个顶点之间都有一条边  顶点数n、边数e，满足：

*   -- 若G是有向图，则  e=n(n-1);
*   -- 若G是无向图，则  e=n(n-1)/2;



**稀疏图**：N个顶点，很少条边(弧)；

**稠密图**：N个顶点，很多条边(弧)；



(顶点间)**邻接**、(顶点与边)**关联**：

-- 有向图中，若存在1条边<A, C>，

  则称：A邻接到C  或 C邻接于A ;

​        边<A, C>与顶点A, C 相关联; 

-- 无向图中，若存在1条边 (A, D)，

  则称：A与D邻接;

​        边(A, D)与顶点A, D 相关联; 



顶点的度D(V)，(有向图顶点的)**入度**和**出度**：

  -- **有向图**：

​    V的入度：以V为终点的边数；

​    V的出度：以V为起点的边数；

​    V的度：入度 + 出度；

  -- **无向图**：

​    V的度：V的关联边的个数；

  à边数 e = 0.5 × ∑(所有顶点的度)



**路径**：在一个顶点序列V**0**, V**1**, **…**, V**n**中，

​       若  V**i** 都能邻接到V**i+1**，

​       则，(V**0**,**…**,V**n**) 是1条路径；

**路径长度**：该路径上的边数 or (**顶点数-1**)；



**回路**：起点与终点**相同**的一条路径；

**简单路径**：只有起点和终点可以相同，即**内部无回路**；

**简单回路**：起点和终点相同的简单路径；



**有根图** ->  一个顶点V可以到达所有的顶点

**连通图** -> 任意两个顶点都连通



•（无向图中的）**连通、连通图**

  -- V**i**与V**k**连通：V**i**与V**k**之间至少**存在1条路径**；

  -- 连通图：图中**任意两个顶点**都连通；

  -- 连通分量  **极大连通子图**

<img src="C:/Users/17363/AppData/Roaming/Typora/typora-user-images/image-20240628152011806.png" alt="image-20240628152011806" style="zoom:33%;" />

•（有向图中的）**强连通图、强连通分量**

  -- 强连通图：任意两个顶点V**i**与V**k**,  从V**i**到V**k** 、从V**k**到V**i**都有路径；

  -- 强连通分量：有向图G的最大强连通子图；

<img src="C:/Users/17363/AppData/Roaming/Typora/typora-user-images/image-20240628152150769.png" alt="image-20240628152150769" style="zoom:33%;" />

* 带权图：每1条边都被赋予一定权值；

* 带权路径长度：路径上，所有边的权值之和；

* **网络**：带权的连通图；





### 图的表示

#### 邻接矩阵

##### 基本概念

图 = 顶点表 + 关系矩阵(邻接矩阵)

  -- 顶点表vexs：顶点组成的1维数组，长度n；

  -- 关系矩阵arcs：描述任意两个顶点间是否有边    **大小：n*n**

* 1 ，若(v**i**,v**j**) 或 <v**i**,v**j**>是G的边
* 0，otherwise

<img src="C:/Users/17363/AppData/Roaming/Typora/typora-user-images/image-20240628152829686.png" alt="image-20240628152829686" style="zoom:33%;" />

<img src="C:/Users/17363/AppData/Roaming/Typora/typora-user-images/image-20240628152955964.png" alt="image-20240628152955964" style="zoom:33%;" />

<img src="C:/Users/17363/AppData/Roaming/Typora/typora-user-images/image-20240628153041724.png" alt="image-20240628153041724" style="zoom:33%;" />

<img src="C:/Users/17363/AppData/Roaming/Typora/typora-user-images/image-20240628153259648.png" alt="image-20240628153259648" style="zoom:33%;" />

##### 存储

```c++
图 = 顶点表 + 关系矩阵(邻接矩阵)
   typedef  char  VexType; 
   typedef  float  ArcType; 
   typedef struct
   { int vexNum, arcNum; 
     VexType vexs[vn]; 
     ArcType  arcs[vn][vn]; 
    } GraphMatrix; 
```

##### 查找

<img src="C:/Users/17363/AppData/Roaming/Typora/typora-user-images/image-20240628154530343.png" alt="image-20240628154530343" style="zoom:33%;" />

##### 创建

1. 输入顶点数 vexNum和 边数arcNum
2. 初始化邻接矩阵  0（对角线） 和 正无穷
3. 输入顶点  到顶点数组
4. 输入边 边    可以==查找==到**索引地点**后建立，也可以直接用数值建立

##### 操作

<img src="C:/Users/17363/AppData/Roaming/Typora/typora-user-images/image-20240628154742076.png" alt="image-20240628154742076" style="zoom:33%;" />

<img src="C:/Users/17363/AppData/Roaming/Typora/typora-user-images/image-20240628154933479.png" alt="image-20240628154933479" style="zoom:33%;" />

<img src="C:/Users/17363/AppData/Roaming/Typora/typora-user-images/image-20240628155016715.png" alt="image-20240628155016715" style="zoom:33%;" />

<img src="C:/Users/17363/AppData/Roaming/Typora/typora-user-images/image-20240628155155179.png" alt="image-20240628155155179" style="zoom:33%;" />



<img src="C:/Users/17363/AppData/Roaming/Typora/typora-user-images/image-20240628155930490.png" alt="image-20240628155930490" style="zoom:33%;" />

#### **邻接表**

##### 基本概念

**无向图**

<img src="C:/Users/17363/AppData/Roaming/Typora/typora-user-images/image-20240628155953996.png" alt="image-20240628155953996" style="zoom:33%;" />

<img src="C:/Users/17363/AppData/Roaming/Typora/typora-user-images/image-20240628160258900.png" alt="image-20240628160258900" style="zoom:33%;" />

**有向图**   出边表

<img src="C:/Users/17363/AppData/Roaming/Typora/typora-user-images/image-20240628160442462.png" alt="image-20240628160442462" style="zoom:33%;" />

<img src="C:/Users/17363/AppData/Roaming/Typora/typora-user-images/image-20240628160507845.png" alt="image-20240628160507845" style="zoom:33%;" />

​		求vi的**入度**？ 依次检查每个出边表，  计算vi下标出现的总次数

**有向图**   入边表

<img src="C:/Users/17363/AppData/Roaming/Typora/typora-user-images/image-20240628160709082.png" alt="image-20240628160709082" style="zoom:33%;" />



##### 数据结构

<img src="C:/Users/17363/AppData/Roaming/Typora/typora-user-images/image-20240628161120311.png" alt="image-20240628161120311" style="zoom:33%;" />

<img src="C:/Users/17363/AppData/Roaming/Typora/typora-user-images/image-20240628161126938.png" alt="image-20240628161126938" style="zoom:33%;" />

<img src="C:/Users/17363/AppData/Roaming/Typora/typora-user-images/image-20240628161253775.png" alt="image-20240628161253775" style="zoom:33%;" />

##### 创建

1. 输入顶点数 装入顶点表
2. 输入边   查找对应的 索引
3. 分配边表空间  头插法 插入边表
4. 无向图 双向

<img src="C:/Users/17363/AppData/Roaming/Typora/typora-user-images/image-20240628161823341.png" alt="image-20240628161823341" style="zoom:33%;" />

<img src="C:/Users/17363/AppData/Roaming/Typora/typora-user-images/image-20240628161839537.png" alt="image-20240628161839537" style="zoom:33%;" />

##### 操作

<img src="C:/Users/17363/AppData/Roaming/Typora/typora-user-images/image-20240628161859239.png" alt="image-20240628161859239" style="zoom:33%;" />

```c++
arcNode * p =G->vexs[i].edgelist;
while(p!=null)
   if(p->adjVex== j)   return 1;
return 0;   //失败

```

<img src="C:/Users/17363/AppData/Roaming/Typora/typora-user-images/image-20240628161931436.png" alt="image-20240628161931436" style="zoom:33%;" />

例，在有向图的出边表中，求vi的入度 

 -- 外层for循环，依次取得每个出边表头指针；

 -- 内层while循环，计算“当前”出边表中，

  vi下标出现的次数 

```c++
indegree = 0;  //有向图出边表，计算i的入度
for(k=0; k<G->vexNum; i++)
{    p= G->vexs[k].edgelist;
     while(p!=null)    
             if(p->adjVex == i)    //统计下标i出现的次数
                      indegree ++; 
}
```

 ==//时间复杂度： *O*(n+e)==

<img src="C:/Users/17363/AppData/Roaming/Typora/typora-user-images/image-20240628162116147.png" alt="image-20240628162116147" style="zoom:33%;" />

<img src="C:/Users/17363/AppData/Roaming/Typora/typora-user-images/image-20240628162155065.png" alt="image-20240628162155065" style="zoom:33%;" />

```C++
arcNode* p = G->vexs[i].edgelist;
while(p!=null)
   if(p->adjVex== j)   break;
k = p->next->adjVex;
return (k);
```

<img src="C:/Users/17363/AppData/Roaming/Typora/typora-user-images/image-20240628162717925.png" alt="image-20240628162717925" style="zoom:33%;" />





### 图的遍历

#### 基本概念

图的复杂性：

  -- 多对多的关系；

  -- 可能有回路；

  -- 可能非连通；

遍历：每个顶点都访问，且只访问1次；

**顶点表----访问标志：数组visited，**

bool visited[vexNum];  //visited[i]=0, 则vi未被访问

<img src="C:/Users/17363/AppData/Roaming/Typora/typora-user-images/image-20240628164051158.png" alt="image-20240628164051158" style="zoom:33%;" />

```c++
void Traverse (Graph G, bool * visited)
    {   for( int i=0; i<G.vexNum; i++)    visited[i]=0; 
        vexNode v;   
        for( int i=0;  i<G.VexNum;  i++)
        {    v = G.vexs[i]; 
             if(visted[i]==0)  dfs(G, v, visited); 
        }
    }
```

#### DFS

深度优先遍历(搜索、周游)

  Depth-First Search (DFS)



<img src="C:/Users/17363/AppData/Roaming/Typora/typora-user-images/image-20240628183908324.png" alt="image-20240628183908324" style="zoom:33%;" />

**递归方法**

* 顶点v 搜索索引
* 标记为 1  输出数据
* 第一个邻接
* while 是节点范围内
  * 没访问过 dfs此节点
  * 下一个邻接 直至不是节点范围

```c++
void dfs( Graph G, vexType v, bool * visited)
{  int index_v = searchVertex(G, v);   // 从v开始遍历
   int index_w;
   printf(“%c”, v);     visited[index_v]  =1;   // 标记已经访问过
   index_w = firstAdjacent(G, index_v); 
   while( index_w >= 0 ) // 节点在范围内
       if( visited[ index_w ] ==0 )   // 并且没被访问过
           dfs(G, G.vexs[index_w ]);  // 递归
      index_w=nextAdjacent(G, index_v, index_w);   // 还有其他的临界点
} 

```

<img src="C:/Users/17363/AppData/Roaming/Typora/typora-user-images/image-20240628183929149.png" alt="image-20240628183929149" style="zoom:33%;" />

<img src="C:/Users/17363/AppData/Roaming/Typora/typora-user-images/image-20240628184126078.png" alt="image-20240628184126078" style="zoom:33%;" />

**非递归方法**

**借助栈**

* 顶点v 搜索索引
* 标记为 1  输出数据
* **建栈  放数据**
* 第一个邻接
* while 栈不空
  * 是节点范围内
    * **访问过**  w=next （找下一个邻接节点）         nextAdjcent( g, ==新栈顶B==, ==刚出栈的w==)，==新栈顶的、在w之后的第1个未被访问的邻接点==
    * 没访问过  **输出数据  标记   进栈  w=next (找w的第一个邻接)**
  * 不是 节点范围 
    * 栈顶出栈

```c++
void dfs(Graph G, vexType v, bool * visited)
{  int index_v=searchVertex(G, v); // v的索引
   Stack st;       VexNode w; 
   int m = G.vexNum; 
   St = createEmptyStack(m);   // 建空栈
   printf(“start vertex %c,” v);                       // 输出顺序为 深度优先序列
   visited[index_v]= 1;     // 标记为1
   push(index_v, St);        // 进栈
   w = firstAdjacent(G, index_v);   // 找第一个邻接点
 while( !isEmptyStack ( St ) )   // 栈不空
 { if(w >=0)
     {  if(visited[w]==1)  // //已访问, 取栈顶的下1邻接点
             w = nextAdjacent(G, top(St), w); 
        else   //若未访问过, 则访问、标记、进栈、继续取
        {   printf(“%c,” G.vexs[w]);				// 输出
            visited[w]= 1;       push(w, St); 
            w=firstAdjacent(G,w);
         }
      }
   else {w=top(St);  pop(St);} //走不动, 则栈顶出栈
  }} //实现：取新栈顶的、相对于w的下一个邻接点
```

<img src="C:/Users/17363/AppData/Roaming/Typora/typora-user-images/image-20240628190004370.png" alt="image-20240628190004370" style="zoom:33%;" />





<img src="C:/Users/17363/AppData/Roaming/Typora/typora-user-images/image-20240628190222709.png" alt="image-20240628190222709" style="zoom:33%;" />

连通图的DFS生成树：

n个顶点，n-1条边；

-- 特点：

1. 不存在回路；
2. 少任何边都不连通；
3. 加入原图的任何边，都会产生回路。



•树边：DFS生成树中的边；

•**后向边**(反向边、回边)：

  原图中的1条边<u, v>，

  满足：在DFS生成树中，u是v的子孙；

•**前向边**：

  原图中的1条边<u, v>，

  满足：在DFS生成树中， u是v的祖先；

•横跨边(横向边)：所有其他的边；


#### BFS

广度优先遍历(搜索、周游)

  Breadth-First Search (BFS)

<img src="C:/Users/17363/AppData/Roaming/Typora/typora-user-images/image-20240628191118569.png" alt="image-20240628191118569" style="zoom:33%;" />

<img src="C:/Users/17363/AppData/Roaming/Typora/typora-user-images/image-20240628191141792.png" alt="image-20240628191141792" style="zoom:33%;" />

**非递归**

* 顶点 v 索引下标   进队
* 标记为 1  输出
* while队不空
  * 取队头  删除
  * 找队头的第一个 邻接点  ==while节点在范围内==
    * 未访问     ==标记为1 进队   输出==
    * 访问 下一个

```c++
void bfs(Graph G, vexType v, bool * visited)
{  int u, w;  //队头、当前顶点下标
   int index_v=searchVertex(G, v);     // 下标
   Queue Q = createEmptyQueue();  //建空队
   visited[index_v] = 1; 
   printf(“%c,” v); //访问、进队
   enQueue(Q, index_v); 
 //接下来，当队不空, 
// 访问队头的未被访问的邻接点, 队头出队
while( ! isEmptyQueue(Q) )
{  u= frontQueue(Q);  
   deQueue(Q); 
   w= firstAdjacent(G, u); //第1个邻接点
   while(w >=0)
       if( visited[ w ] ==0 )   //若未访问,则访问、进队 
       {   visited[ w ] =1; 
           printf(“%c,” G.vexs[ w ]); 
           enQueue(Q, w); 
       }
       w = nextAdjacent(Q, u, w);  //下一个
    }
}
```

<img src="C:/Users/17363/AppData/Roaming/Typora/typora-user-images/image-20240628192352895.png" alt="image-20240628192352895" style="zoom:33%;" />

<img src="C:/Users/17363/AppData/Roaming/Typora/typora-user-images/image-20240628192413110.png" alt="image-20240628192413110" style="zoom:33%;" />

•如何寻找一个**无权图中某个顶点v到其它顶点的最短路径**？

•从顶点v开始BFS    记录其余节点到v的最短路径长度



### 最小生成树

#### 基本概念

<img src="C:/Users/17363/AppData/Roaming/Typora/typora-user-images/image-20240628192624210.png" alt="image-20240628192624210" style="zoom:33%;" />

<img src="C:/Users/17363/AppData/Roaming/Typora/typora-user-images/image-20240628192739799.png" alt="image-20240628192739799" style="zoom:25%;" />

#### prim

##### 基本概念

**Prim算法 — 加边加点法**；   •加n-1次

> 普里姆算法其实就是结点优先算法，从图中==任意一个结点==开始，每次都找一个==权值最小的边==，将这两个结点连接起来，然后在生成的**新整体**中继续找一个权值最小的边，将新整体和最小边的终点连接起来，以此往复，直到所有的结点全部被包含进来。

<img src="C:/Users/17363/AppData/Roaming/Typora/typora-user-images/image-20240628192803213.png" alt="image-20240628192803213" style="zoom:33%;" />

<img src="C:/Users/17363/AppData/Roaming/Typora/typora-user-images/image-20240628193016801.png" alt="image-20240628193016801" style="zoom: 25%;" />

##### 实现算法1

<img src="C:/Users/17363/AppData/Roaming/Typora/typora-user-images/image-20240628193117559.png" alt="image-20240628193117559" style="zoom:33%;" />

<img src="C:/Users/17363/AppData/Roaming/Typora/typora-user-images/image-20240628193417054.png" alt="image-20240628193417054" style="zoom:33%;" />

<img src="C:/Users/17363/AppData/Roaming/Typora/typora-user-images/image-20240628193748524.png" alt="image-20240628193748524" style="zoom:33%;" />

<img src="C:/Users/17363/AppData/Roaming/Typora/typora-user-images/image-20240628193930593.png" alt="image-20240628193930593" style="zoom:33%;" />

<img src="C:/Users/17363/AppData/Roaming/Typora/typora-user-images/image-20240628194149846.png" alt="image-20240628194149846" style="zoom:33%;" />

##### 实现算法2

<img src="C:/Users/17363/AppData/Roaming/Typora/typora-user-images/image-20240628194420258.png" alt="image-20240628194420258" style="zoom:33%;" />

<img src="C:/Users/17363/AppData/Roaming/Typora/typora-user-images/image-20240628194944865.png" alt="image-20240628194944865" style="zoom:33%;" />

<img src="C:/Users/17363/AppData/Roaming/Typora/typora-user-images/image-20240628195007740.png" alt="image-20240628195007740" style="zoom:33%;" />

<img src="C:/Users/17363/AppData/Roaming/Typora/typora-user-images/image-20240628195111189.png" alt="image-20240628195111189" style="zoom:33%;" />

<img src="C:/Users/17363/AppData/Roaming/Typora/typora-user-images/image-20240628201422791.png" alt="image-20240628201422791" style="zoom:33%;" />



##### 代码实现

* 初始化 mst数组
  * st为 0（选定0）  ed为本身   权重为之间的 权值
* 加边  选n - 1条   大循环
  * 设置 最小值  标记 （找到最小值 的索引） i ~ n-2
  * 如果最小值  不在 第二个位置  ==交换位置==   min 与 i （第几次循环）
  * 用新进的顶点  ==更新==其他顶点的 距离    i + 1 ~ n - 2
    * 找vy索引
    * vx vy边长 与 原边长 比较
      * 小  ==修改边长  和 start==

```c++
 typedef struct
 {  int  start_vex, stop_vex;
    AdjType  weight;  } Edge; 

void prim(GraphMatrix * pgraph, Edge mst[ ])  //最终目的：获得mst数组
{ int i, j, min, vx, vy;
  double weight;
  Edge edge;   //Edge是mst数组元素类型
  for(i=0; i<VN-1; i++)   //初始U={v0}, 初始化mst数组
  {     mst[i].start_vex = 0;
        mst[i].stop_vex = i+1;
        mst[i].weight = pgraph->arcs[0][i+1]; } 
// 依次选出n-1条边加入到生成树中
 for( i=0; i<VN-1; i++ )   
{   weight = Max;    min=i;   
    for( j=i; j<VN-1; j++)  //找mst[i]~n-2中最值mst[min]
          if( mst[ j].weight <weight )
          {   weight = mst[ j].weight;   min=j; }
    if( min != i )
    {   edge=mst[min];     mst[min]=mst[i]; 
        mst[i]=edge; }
 
 vx = mst[i].stop_vex; //vx是刚进入U的新顶点

//下面考察，新入顶点vx能否修改mst[i+1]……mst[n-2]
for( j=i+1; j<VN-1; j++)
{    vy =mst[ j].stop_vex;
     weight = pgraph->arcs[vx][vy]；
     if( weight < mst[ j].weight)
     {   mst[j].weight = weight;
         mst[j].start_vex = vx; }
     }
}}


```

==时间复杂度-- O(n2)==

#### Kruskal

**Kruskal算法 — 加边法**； •加n-1次

> 一直选最小的边长，直至所有点都连起来

<img src="C:/Users/17363/AppData/Roaming/Typora/typora-user-images/image-20240628202925818.png" alt="image-20240628202925818" style="zoom:33%;" />

<img src="C:/Users/17363/AppData/Roaming/Typora/typora-user-images/image-20240628203006376.png" alt="image-20240628203006376" style="zoom:33%;" />

<img src="C:/Users/17363/AppData/Roaming/Typora/typora-user-images/image-20240628203101011.png" alt="image-20240628203101011" style="zoom:33%;" />

<img src="C:/Users/17363/AppData/Roaming/Typora/typora-user-images/image-20240628203237236.png" alt="image-20240628203237236" style="zoom:33%;" />

<img src="C:/Users/17363/AppData/Roaming/Typora/typora-user-images/image-20240628203321656.png" alt="image-20240628203321656" style="zoom:33%;" />

代码实现

* 初始化vexSet数组  每个点都是==孤立点==
* cnt 记录==加边的数量==
* 路径从小到大  取==边 的两端的 索引==   并==取索引在vexSet中的数值==  s1 = vexSet(x1)
  * 若 不联通  
    * 将v1 v2放入mst数组或者输出
    * ==全面更新 vexSet数组==  for循环  
    * 用cnt记录 是否加了 n - 1条边  break

```c++
void MiniSpanTree_kruskal(AMGraph G)
{  Sort(Edge);    int count=0, s1, s2;
   for(i=0; i<G.vexNum; i++)    vexSet[i] = i;  //孤立点  
   for(i=0; i<G.arcNum;i++)
   {   v1 = searchVertex( Edge[i].head);  s1=vexSet(v1);
       v2 = searchVertex( Edge[i].head);  s2=vexSet(v2);
        if( s1 != s2)  //不连通
        {   printf(…)   //将(v1, v2)放入mst数组，或输出
            for(j=0; j<G.vexNum; j++)  //全面更新vexSet
                  if(vexSet[j] == s2)     
                      vexSet[j] = s1;
             if(count++ == G.vexNum-1)     break;
        }
   }
}
```

#### 并查集





### 最短路径

#### 基本概念

•带权路径长度：路径上, 各边的权值之和；

•最短路径：长度最短的路径；



换乘少：BFS -> 弱化权值

花费少：Dijkstra等算法 ->  路径上权值之和



•**单源点，最短路径**；

  -- Dijkstra算法；(要求，权重非负)

  -- Bellman-Ford算法 (权重可以负，但无负权回路)

•求**任意两点**之间的最短路径；

  -- Floyd算法；



#### Dijkstar算法

> -- 假设所有边的权重都 >0
>
> -- 按照长度递增的次序产生  v0到各顶点的最短路径；

<img src="C:/Users/17363/AppData/Roaming/Typora/typora-user-images/image-20240628204923393.png" alt="image-20240628204923393" style="zoom:33%;" />

• 基本思想：

 用“**已经确定最短路径的顶点”**，作为中间点， 修正“未确定”的路径。

<img src="C:/Users/17363/AppData/Roaming/Typora/typora-user-images/image-20240628205133156.png" alt="image-20240628205133156" style="zoom:33%;" />

<img src="C:/Users/17363/AppData/Roaming/Typora/typora-user-images/image-20240628205321087.png" alt="image-20240628205321087" style="zoom:33%;" />

<img src="C:/Users/17363/AppData/Roaming/Typora/typora-user-images/image-20240628205355619.png" alt="image-20240628205355619" style="zoom:33%;" />



<img src="C:/Users/17363/AppData/Roaming/Typora/typora-user-images/image-20240628205407029.png" alt="image-20240628205407029" style="zoom:33%;" />

<img src="C:/Users/17363/AppData/Roaming/Typora/typora-user-images/image-20240628205554077.png" alt="image-20240628205554077" style="zoom:33%;" />

**代码**

数据结构     结构体  记录 路径（边长  和  前缀顶点） arcs[ ] [ ]标记是否更新过

* 初始化
  *  0 0
  * arcs[0] [0] 标记为 1
  * 用 0 更新 dist[1] ~ N - 1
    * 不是 正无穷  前置节点为0
    * 是  前置节点为 -1
* 循环 N-1次 找每个的最短路径
  * 没被标记过 ==arcs[] [] = 0 && 距离更小==  找最小距离
  * ==特判== 最后会有不联通的情况  if(minw==Max)  break;
  * 将顶点加入U集合   标记 ==已经更新过==
  * ==更新 其他距离==  未标记过的
    * `dist[j].length > dist[min].length + ar [min] [j]` （更新最小点 到 j的距离）
    * ==更新前驱==

```c++
# define Max 1000;   //声明常量Max
typedef struct
{    float  length;     //路径长度
     int  prevex;        //前驱顶点
} Path; 
Path dist[VN]; 

void initial(GraphMatrix *pgraph, Path dist[ ])
{ int i;     //首先，初始化dist数组：(路长, 前驱顶点)
  dist[0].length =0;   dist[0].prevex =0;  //设置dist[0]
  pgraph->arcs[0][0]=1;  //设置arcs[0][0]
  for( i=1; i<VN; i++) //用arcs第0行初始化dist[1]~VN-1
  {     dist[i].length = pgraph->arcs[0][i]; 
         if( dist[i].length != Max)
                  dist[i].prevex = 0;
         else  dist[i].prevex = -1;
   } 
}

void dijkstra( GraphMatrix *G, Path dist[ ])
{ int  i, j, min;   float  minw;  //minw: 记录最小长度
  initial(G, dist);   //初始化dist数组
  for( i=1; i<VN; i++)  //循环N-1次, 求N-1条最短路径
  {   minw =Max;  min=0; 
      for( j=1; j<G->vexNum; j++)
      {   if( G->arcs[j][j]==0)&&(dist[j].length<minw)) //1.找最小值
          {  minw = dist[j].length;    min = j;
      } }
      if(minw==Max)   break; 

  G->arcs[min][min]=1; 
  for( j=1; j<VN; j++) //2.2更新“未确定”的路径长度
  {   if(G->arcs[j][j]==0)
            && (dist[ j].length > dist[min].length  
                                       +G->arcs[min][ j] ))
            { dist[ j].length =
              dist[min].length + G->arcs[min][ j];
              dist[j].prevex = min; 
             }
  } } } 
```

==Dijkstra算法复杂度：O(n2)==



### 拓扑排序

1.工程能否顺利完成？   -- 拓扑排序

2.完成工程所需的最短时间？ -- 关键路径

AOV网

  顶点 ---- 活动；

  有向边(弧) ---- 活动的优先关系

<img src="C:/Users/17363/AppData/Roaming/Typora/typora-user-images/image-20240628212157488.png" alt="image-20240628212157488" style="zoom:33%;" />

若AOV网中有回路，工程能否完成？  不能

  -- 有向图存在1个拓扑序列  <-->  无回路

AOV网的拓扑序列，唯一？ 不一定

<img src="C:/Users/17363/AppData/Roaming/Typora/typora-user-images/image-20240628212313030.png" alt="image-20240628212313030" style="zoom:33%;" />

<img src="C:/Users/17363/AppData/Roaming/Typora/typora-user-images/image-20240628212417448.png" alt="image-20240628212417448" style="zoom:33%;" />



<img src="C:/Users/17363/AppData/Roaming/Typora/typora-user-images/image-20240628212510012.png" alt="image-20240628212510012" style="zoom:33%;" />

<img src="C:/Users/17363/AppData/Roaming/Typora/typora-user-images/image-20240628212813655.png" alt="image-20240628212813655" style="zoom:33%;" />

**代码实现**

栈来实现

* 初识化 入度 数组    
  * 依次遍历 N条边
* 用 count 记录 有多少个顶点进入   （判断回路）
* 入度为0的进栈
* while栈不空
  * ==取栈顶t  进入拓扑数组  弹出栈顶==
  * 取t的出边表
    * while != null
    * 对应顶点的 入度 -1   
      * 如果入度为0  ==进栈==

```c++
//计算入度，数组indegree
void findInDegree(GraphList *g, int * indegree)
{ int i;       arcNode *  p; 
  for (i=0; i<VN; i++)    indegree[i] =0; 
  for(i=0; i<VN; i++)
         p= g->vexs[i].edgelist; 
         while( p ) 
             ++ indegree[ p->adjvex ]; //该边终点入度
             p= p->next; 
  }
}

// 拓扑排序
int topoSort( GraphList * G, int * ptopo) // i取栈顶入ptopo
{ int i, k, indegree[VN], count=0;
  PSeqStack  s = createEmptyStack_seq(VN);
  arcNode *  p;
  findInDegree(G, indegree);
  for(i=0; i<VN; i++)  //初始，入度为0者进栈
       if( indegree[i]==0)     push(s, i);
  //接下来，while栈不空，“删除”栈顶及其出边，即：修正出边终点的Indegree
while( ! isEmptyStack(s) )
    i=top(s);    ptopo[count ++]=i;    
    pop(s);     
    while(p != null)  //“删”出边、新入度为0者进栈
        k=p->endvex;    indegree[k]--;      // 出边终点,入度-1
        if( indegree[k]==0 )   push(s, k);
        p=p->nextedge;
    }
}
if(count<VN)    return 0;    //有回路
else                 return 1;  }

```

<img src="C:/Users/17363/AppData/Roaming/Typora/typora-user-images/image-20240628214045313.png" alt="image-20240628214045313" style="zoom:33%;" />

<img src="C:/Users/17363/AppData/Roaming/Typora/typora-user-images/image-20240628214120193.png" alt="image-20240628214120193" style="zoom:33%;" />

<img src="C:/Users/17363/AppData/Roaming/Typora/typora-user-images/image-20240628214227269.png" alt="image-20240628214227269" style="zoom:33%;" />



### 关键路径

事件是顶点ee le    活动是边 e l

**AOE(**activity on Edge)网：

  有向边(弧) ---- 活动；

  顶点 ---- 事件：入边活动完成，出边可开始；

<img src="C:/Users/17363/AppData/Roaming/Typora/typora-user-images/image-20240628214345634.png" alt="image-20240628214345634" style="zoom:33%;" />

<img src="C:/Users/17363/AppData/Roaming/Typora/typora-user-images/image-20240628214410341.png" alt="image-20240628214410341" style="zoom:33%;" />

##### 事件的最早发生时间

事件vj可能的最早发生时间 ee(j)？

  -- 从‘源点’到vj的‘最长路径长度’ ；

​    且，事件发生后，其出边活动才能开始；

<img src="C:/Users/17363/AppData/Roaming/Typora/typora-user-images/image-20240628214547607.png" alt="image-20240628214547607" style="zoom:33%;" />

<img src="C:/Users/17363/AppData/Roaming/Typora/typora-user-images/image-20240628214738925.png" alt="image-20240628214738925" style="zoom:33%;" />

##### 事件的最迟发生时间

事件vi允许的最迟发生时间 le(i)？

  -- 汇点：允许的最迟 == 最早发生time

  -- 其余：不能影响 ”其后继事件vj” 的最迟发生时间；

<img src="C:/Users/17363/AppData/Roaming/Typora/typora-user-images/image-20240628214824327.png" alt="image-20240628214824327" style="zoom:33%;" />

<img src="C:/Users/17363/AppData/Roaming/Typora/typora-user-images/image-20240628215031669.png" alt="image-20240628215031669" style="zoom:33%;" />



##### 活动的最早开工时间

<img src="C:/Users/17363/AppData/Roaming/Typora/typora-user-images/image-20240628215130077.png" alt="image-20240628215130077" style="zoom:33%;" />

<img src="C:/Users/17363/AppData/Roaming/Typora/typora-user-images/image-20240628215559075.png" alt="image-20240628215559075" style="zoom:33%;" />

##### 活动的最晚开工时间

<img src="C:/Users/17363/AppData/Roaming/Typora/typora-user-images/image-20240628215659871.png" alt="image-20240628215659871" style="zoom:33%;" />

<img src="C:/Users/17363/AppData/Roaming/Typora/typora-user-images/image-20240628215811770.png" alt="image-20240628215811770" style="zoom:33%;" />

##### 关键活动

<img src="C:/Users/17363/AppData/Roaming/Typora/typora-user-images/image-20240628215845010.png" alt="image-20240628215845010" style="zoom:33%;" />

<img src="C:/Users/17363/AppData/Roaming/Typora/typora-user-images/image-20240628215858145.png" alt="image-20240628215858145" style="zoom:33%;" />

##### 算法实现

<img src="C:/Users/17363/AppData/Roaming/Typora/typora-user-images/image-20240628220148855.png" alt="image-20240628220148855" style="zoom:33%;" />

<img src="C:/Users/17363/AppData/Roaming/Typora/typora-user-images/image-20240628220212766.png" alt="image-20240628220212766" style="zoom:33%;" />

**代码实现**

```c++
有向图，出边表示：
   struct EdgeNode; 
   typedef struct EdgeNode * PEdgeNode;
   typedef struct EdgeNode * EdgeList; 
   struct EdgeNode
   { int  endVex;  //邻接顶点(出边终点)的下标
     AdjType  weight; 
     PEdgeNode  nextEdge;  //指向下一条边
   };
      typedef struct
      {   VexType  vertex; //顶点信息
          EdgeList  edgelist; 
      } VexNode; //顶点表中元素类型
      typedef struct
      {   VexNode  vexs[VN];//顶点表（1维数组）
          int  vexNum, arcNum; //顶点个数, 边数
      } GraphList; // 图的结构类型

int criticalPath( GraphList * paoe)
{  Adjtype ee[n], le[n];   Edgelist p;   int i, j=0, ptopo[n];
   if(toposort(paoe, ptopo)==0)  return 0;  
   comp_ee(paoe, ptopo, ee);
   comp_le(paoe, ptopo, le);//1.按拓扑序,计算各顶点的ee,le
   for( i=0;  i<n;  i++)//2. 检查每个边表，寻找关键边
        p=pao->vexs[i].edgelist;  // j：i 的出边的终点的下标 
        while (p)   
              j=p->endvex;   
              if( ee[i] == le[ j ] － p->weight)     printf(……)  //判断<vi, vj>是否关键边
              p=p->nextedge;  
        
   return 1;   }

void comp_ee(Graphlist *paoe, int *ptopo, Adjtype ee[])
{  int i, j, t;    Edgelist p;
   for(i=0; i<n; i++)  ee[i]=0;  //按拓扑序, 利用所有入边起点的ee值间接，用已知的ee(i)，将i的“出边终点”的ee调大
   for(t=0;  t<n;  t++) 
   {   i = ptopo[t];  
       p=paoe->vexs[i].edgelist;   //p：i的出边表的头指针
       for( ;  p!=Null;  p=p->nextedge) //遍历i的出边表,调ee[j]
           j=p->endvex;   // i: 起点, j: 终点, 边：<vi,vj>
           if( ee[ j] < ee[i] + p->weight )
               ee[ j] = ee[i] + p->weight;  //ee[j]是否需要修改？  
    						// 调整规则：若ee[ j]能变大，则立即变大
							// 依据：ee( j)= max{ee(i) + weight<vi, vj> }
       }
   }
}

void comp_le(Graphlist *paoe, int *ptopo, Adjtype ee[])
{  int i, j, t;    Edgelist p;
   for(i=0; i<n; i++)  le[i]=ee[n-1];
   for(t=n-2;  t>=0;  t--)  //逆拓扑序, 利用所有出边终点的le直接，遍历i的出边，用终点le(j)，将le(i)调小
   {   i = ptopo[t];   
       p=paoe->vexs[i].edgelist;     //p：i的出边表的头指针
       for( ;  p!=Null;  p=p->nextedge)
           j=p->endvex;   
           if( le[i] > le[ j] - p->weight ) // le[i]是否需要修改？
               le[i] = le[ j] - p->weight;
       }
   }
}

```





## 排序

<img src="C:/Users/17363/AppData/Roaming/Typora/typora-user-images/image-20240628235846565.png" alt="image-20240628235846565" style="zoom:33%;" />

<img src="C:/Users/17363/AppData/Roaming/Typora/typora-user-images/image-20240628235833695.png" alt="image-20240628235833695" style="zoom:33%;" />

<img src="C:/Users/17363/AppData/Roaming/Typora/typora-user-images/image-20240629001742555.png" alt="image-20240629001742555" style="zoom:33%;" />

### 插入排序

基本思路：每1步(趟)：将1个待排序记录，按排序码大小，**插入到“已经排好序”的序列中**

#### 直接插入排序

==稳定==

--“已排序”码  从右向左，依次 

* 若比 k~i~大，则直接后移

* 若== or < k~i~则停止移动，k~i~放入空位置

适用于：n值较小，且基本有序

<img src="C:/Users/17363/AppData/Roaming/Typora/typora-user-images/image-20240628222743410.png" alt="image-20240628222743410" style="zoom:33%;" />

**代码算法**

* 循环 n - 1 次  1~n- 1  从第一个开始  ==（第0个默认有序）==
  * temp 等于当前 位置数
  * 从 i -1 ~ 0 对比 （从右往左找）
    * temp存储数据 
    * 本身数据 大于  本身数据直接右移 腾空位置

```c++
存储结构 -- 顺序存储
    typedef struct
    {    int  key;  //排序码key
         char  info;
    } RecordNode;
    typedef struct
    {    int  n;  //“记录”的个数
         RecordNode * record;  //指针record指向“记录”
    } SortObject;  //“记录表” 结构
   
void insertSort( SortObject * pvector)
{  int i, j;
   RecordNode temp, * data = pvector->record; 
   for( i=1; i < pvector->n ; i++)  //为R1, …, Rn-1找插入位置
        temp = data[i];
        for( j= i-1;  j>=0;  j--) //Ki依次与Ki-1, Ki-2, ...k0 比较
             if( data[ j].key > temp.key ) //寻找插入位置
                 data[ j+1] = data[ j]; //后移
             else     break;
        }
        if( j != i-1)   data[ j+1] = temp; 
   } 
}  

```

<img src="C:/Users/17363/AppData/Roaming/Typora/typora-user-images/image-20240628225211744.png" alt="image-20240628225211744" style="zoom:33%;" />

代码实现

* data[0]无数据
* 遍历 n-1次 2~n
  * j = i - 1 和前一个数比较
  * while 大于 data[0]
    * 后移  data[j+1] = data[j]
    * j --
  * 插入数据 data[j+1] = data[0]



```c++
void insertSort( SortObject * pvector)
{  RecordNode * data = pvector->record;
   for( i=2; i<=pvector->n; i++)
        data[0] = data[i];
        j = i-1; 
        while( data[j].key > data[0].key)
        {     data[ j+1] = data[ j];    j--; }
        data[ j+1] = data[0]; 
    } 
}  

```



#### 二分插入排序

==稳定==

相比于直接插入排序

* key的比较次数？

  -- 改善，总比较次数 ≈ nlog~2~n

* record移动（赋值）次数？

  -- 没有改善，*O*(n^2^)

<img src="C:/Users/17363/AppData/Roaming/Typora/typora-user-images/image-20240628230127900.png" alt="image-20240628230127900" style="zoom:33%;" />

<img src="C:/Users/17363/AppData/Roaming/Typora/typora-user-images/image-20240628230317674.png" alt="image-20240628230317674" style="zoom:33%;" />

**代码实现**

* 遍历n-1次   1~n
  * temp存储数据  l = 0   r = n -1
  * while (l <= r)
    * mid = （l + r） / 2
    * ==小于==  r = mid - 1   ->  只有小于才会移动  保存稳定性
    * else l = mid + 1
  * 循环后移(从后往前) j-1 ~ l   ==(>=left)== data[j+1] = data[j]   
  * 对j+1赋值  data[j + 1] = temp

```c++
void binSort( SortObject * pvector)
{  int i, j, left, right;    RecordNode temp;  
   RecordNode *data = pvector->record;
   for( i=1; i<pvector->n; i++)
       temp=data[i];   left=0; right=i-1; 
       while( left<=right )
       {    mid = (left+right)/2;
            if( temp.key < data[mid].key )  right = mid-1;
            else                                          left = mid+1;
       }
       for( j=i-1;  j>=left;  j--)    data[j+1] = data[j];
       data[ left ] = temp;
   } 
}  
```

<img src="C:/Users/17363/AppData/Roaming/Typora/typora-user-images/image-20240628231024938.png" alt="image-20240628231024938" style="zoom:33%;" />

#### 希尔排序

> （缩小增量法）

==不稳定==

  -- n个记录，增量为d**i**，则分组

   下标 0,  d**i**,    2d**i**,    3d**i**,    **……** 为1组

   下标 1,  d**i** +1,  2d**i** +1,  3d**i** +1, **……** 为1组

   下标 2,  d**i** +2,  2d**i** +2,  3d**i** +2, **……** 为1组

​    ……  ……  ……  ……

​    下标 d**i**-1,  d**i**+d**i** -1,  2d**i**+d**i** -1, **……** 为1组



* 增量为d~i~时，在各组内，进行 排序

* 减小增量，重新分组，组内 排序

* 重复2， 直到d~i~==1，所有记录在同一组，组内 排序

  <img src="C:/Users/17363/AppData/Roaming/Typora/typora-user-images/image-20240628231212590.png" alt="image-20240628231212590" style="zoom:33%;" />





### 选择排序

#### 简单选择排序

==不稳定==

-- 每1步(趟)：从待排序记录中，**选出最小排序码**顺序放在“已排序记录”之后；

简单选择排序，每次选出1个最小值，但，每次都**“重新”**开始选择

<img src="C:/Users/17363/AppData/Roaming/Typora/typora-user-images/image-20240628231502392.png" alt="image-20240628231502392" style="zoom:33%;" />

**代码实现**

* 循环 n-1 次  每次挑选一个 最后一个默认最大   0 ~ n - 2
  * 将第 i 个数设定为最小 （索引）
  * 循环后面 找有无更小值 i+1 ~ n - 1
    * 更小 ==更新索引==
  * min索引不是 第 i 个 交换

```c++
存储结构 -- 顺序存储
    typedef struct
    {    int  key;  //排序码key
         char  info;
    } RecordNode;//“记录”类型
    typedef struct 
    {    int  n; //“记录”的个数
         RecordNode * record;//指针record指向“记录”
    } SortObject; //“记录”表结构
   
void selectSort( SortObject * pVec)
{  int i, j, min;  
   RecordNode temp, * data = pVec->record;
   for( i=0;  i<pVec->n-1; i++) //共n-1趟，选出n-1个最小
       min=i;  
       for( j= i+1;  j<pVec->n;  j++)
             if( data[ j].key < data[min].key)     min=j; 
       if( min != i) 
           temp = data[i];
           data[i] = data[min];
           data[min] = temp;
      }
   } 
}  
```



#### 堆排序

==不稳定==

1. 将待排序数据 建立成大根堆；
2. 重复：选出最大值（堆顶）、并调整剩余部分

一棵完全二叉树，且满足**堆序性**：

* 根最小--小根堆
* 根最大--大根堆

-- 堆的存储方式：顺序存储

​	完全二叉树的性质：按”从上到下，从左到右”将结点从0开始编号，则：父亲与左、右孩子的编号之间满足一定规律。

<img src="C:/Users/17363/AppData/Roaming/Typora/typora-user-images/image-20240628232339693.png" alt="image-20240628232339693" style="zoom:33%;" />

**建立大根堆**

* 先，将待排序记录建成1个完全二叉树，再**“从后向前”**依次调整
* 按“不断插入新元素”方法，向空 ”大根堆” 中，逐个插入待排序记录



方法1：先，将待排序记录建成1个完全二叉树，再**“从后向前”**依次调整(sift)

1. 判断“待调整 x”是否 **>**左孩子 && **>**右孩子

  -- 1.1 是，则无需调整，结束

  -- 1.2. 否，继续“调整 x”，即：重复1，直到x与孩子满足堆序性，或 x成为叶子

<img src="C:/Users/17363/AppData/Roaming/Typora/typora-user-images/image-20240628233628951.png" alt="image-20240628233628951" style="zoom:33%;" />

<img src="C:/Users/17363/AppData/Roaming/Typora/typora-user-images/image-20240628233719796.png" alt="image-20240628233719796" style="zoom:33%;" />



2. 排序、调整

   2.1 取出 最大值(堆顶)，将其 放入 排序序列

   2.2 调整剩余结点  - >堆

   交换：堆顶 <- -> 最后元素

​		调整堆顶，即sift(0)

<img src="C:/Users/17363/AppData/Roaming/Typora/typora-user-images/image-20240628233954397.png" alt="image-20240628233954397" style="zoom:33%;" />

**时间复杂度**

1.建堆 ->*O*(n)

2.排序、调整

​        每一趟调整 -> 树高，即*O*(logn)

​        共调整n-1趟。

   ->  O(*n*log*n*) 

<img src="C:/Users/17363/AppData/Roaming/Typora/typora-user-images/image-20240628233937916.png" alt="image-20240628233937916" style="zoom:33%;" />



**代码实现**

* 从最后结点的父亲开始  (n- 1-1 )/2  ->  n/2 - 1 ~ 0 循环   ==（建立大根堆）==
  * 倒序 sift 交换  
* 循环n - 1次 n-1 ~ 1   从后往前 （排序 调整）
  * 树根与堆最后 ==交换==  record
  * 对根 sift     (...; i ; 0)

sift实现

* 找左子树
* while ch < size
  * 有 右子树  并且 右子树更大 ch++
  * 父亲 更小  -> 下沉  p = ch   ch = p* 2 + 1
  * 不小 break
* 将temp放入最终位置 [p] = temp

```c++
存储结构 -- 顺序存储
    typedef struct
    {    int  key;
         char  info;
    } RecordNode;
    typedef struct
    {    int  n;
         RecordNode * record;
    } SortObject;
   
void heapSort( SortObject * pVec)
{  int  i, n=pVec->n;     RecordNode temp;
   for( i=n/2-1;  i>=0;  i--)     // (n-1-1)/2: 最后位置的父亲
         sift( pVec, n, i);  //倒序，进行sift，建成大根堆 
   for( i=n-1; i>0; i--)  //n-1次：取出最大值(根), 放在堆之后
      temp = pVec->record[0];   //树根 与 堆中最后 元素交换
      pVec->record[0] =pVec->record[i];
      pVec->record[i] =temp;  
      sift(pVec, i, 0)    //对根（下标0）进行sift 
   }
}

void sift( SortObject * pVec, int size, int p)
{ int  ch=2*p+1;// p: 待sift位置，ch初始为其左子(下标)
  RecordNode  temp=pVec->record[p]; //temp: 待sift元素
  while( ch <size)  //在为temp找到最终位置之前， // temp不参与交换，仅空位置p下沉1层
     if( ch<size-1 && pVec->record[ch].key < pVec->record[ch+1].key) 
        ch ++;  //若右子更大，则ch成为右子  ch记录较大孩子
    if( temp.key < pVec->record[ch].key ) //判断堆序性
        pVec->record[p] = pVec->record[ch]; //大孩子上升
        p=ch;   ch =2*p+1; //位置p下降1层, ch更新为p的左子
    else  break; 
    pVec->record[p] = temp; }//将temp放入最终位置
```



### 交换排序

将待排序码，两两比较，交换不满足“顺序要求”的“偶对”，直到全部满足。

#### 冒泡排序

==稳定==

通过相邻记录的比较，使得：**较大的记录，向右移动**

从而：待排序组内最大记录，**靠最右**

注意：**==发生时  不交换**

==平均时间复杂度：*O*(n^2^)==

冒泡排序中，相邻记录比较，若逆序，则交换  -> 但**，1次交换，只能消除1个逆序** 

<img src="C:/Users/17363/AppData/Roaming/Typora/typora-user-images/image-20240628235948872.png" alt="image-20240628235948872" style="zoom:33%;" />

<img src="C:/Users/17363/AppData/Roaming/Typora/typora-user-images/image-20240629000012246.png" alt="image-20240629000012246" style="zoom:33%;" />

<img src="C:/Users/17363/AppData/Roaming/Typora/typora-user-images/image-20240629000028273.png" alt="image-20240629000028273" style="zoom:33%;" />

**代码实现**

* noSwap标志  提前结束循环
* 循环n-1次 每次==重置noSwap==
  * 待排序部分 0 ~ n-i-1
    * 前面的数大于后面的数   需要交换
    * noSwap置 q1
  * noSwap为0 提前break(已经有序)

```c++
存储结构 -- 顺序存储
    typedef struct
    {    int  key;
         char  info;
    } RecordNode;
    typedef struct
    {    int  n;
         RecordNode * record;
    } SortObject;
   
void bubbleSort( SortObject * pvector)
{  int i, j, noSwap; //noSwap==0：本趟冒泡, 未执行交换
   RecordNode temp, * data = pvector->record;
   for( i=0; i<pvector->n-1; i++)//总共n-1趟冒泡
       noswap=0;
       for( j=0;  j<pvector->n-i-1;  j++)
            if( data[ j].key > data[ j+1].key )
                temp = data[ j];        data[ j] = data[ j+1];
                data[ j+1] = temp;    noswap=1;
            }
       if( noSwap==0)   break; 
   } 
}  

```

<img src="C:/Users/17363/AppData/Roaming/Typora/typora-user-images/image-20240629000730697.png" alt="image-20240629000730697" style="zoom:33%;" />





#### 快速排序

==不稳定==

能否，交换不相邻的记录 -> **1次消除多个逆序？**  快速排序（分区交换排序）

* 从待排序码中，选出1个k（如R~0~.key ）

* 将 小于k的记录移动到左边（左子表），大于k的记录移动到右边（右子表），

* 将k 放在“左、右两个子表”的分界处

-> 为此趟的分区基准k，找到了最终位置

  -- 最好情况

​		每1趟，“待排序列”-> 等长的两个子表

​		-> 总比较次数：C(n) ≤ n+2C(n/2) ≤ **…** ≈*O*(nlog**2**n)

 -- 最坏情况

   待排序记录，已排好序 -> 左or右子表长度为0

  -> 总比较次数：C**max**=(n-1)+(n-2)+…+1 ≈O(n**2**)

<img src="C:/Users/17363/AppData/Roaming/Typora/typora-user-images/image-20240629000854553.png" alt="image-20240629000854553" style="zoom:33%;" />

<img src="C:/Users/17363/AppData/Roaming/Typora/typora-user-images/image-20240629000904029.png" alt="image-20240629000904029" style="zoom:33%;" />



<img src="C:/Users/17363/AppData/Roaming/Typora/typora-user-images/image-20240629000941828.png" alt="image-20240629000941828" style="zoom:25%;" />

<img src="C:/Users/17363/AppData/Roaming/Typora/typora-user-images/image-20240629000951735.png" alt="image-20240629000951735" style="zoom:25%;" />

**代码实现**

* 递归分区
  * l>=r出口
  * temp = data[i]
  * while(i != j)
    * while(i < j && 数据比temp更大等于) j --; 直到找到第一个小于 temp的
    * if(i<j)  data[i++] =data[ j]  直接赋值
    * while(i < j && 数据比temp更小等于) i++; 直到找到第一个大于 temp的
    * if(i<j)  data[j--] =data[ i]
  * 最后把temp赋值 
  * 递归 分区排序

```c++
存储结构 -- 顺序存储
    typedef struct
    {    int  key;
         char  info;
    } RecordNode;
    typedef struct
    {    int  n;
         RecordNode * record;
    } SortObject;
   
void quickSort( SortObject * pvector, int l, int r)
{  if( l >= r)   return;   //递归出口
   RecordNode temp,  * data = pvector->record;
   int  i=l,  j=r;    temp=data[i]; //temp：分区基准
   while( i != j) //1趟快排，为temp寻找最终位置
       while( i<j && data[ j].key >= temp.key)   j--;
       if( i<j )  data[i++] =data[ j]; 
       while( i<j && data[i].key <= temp.key)   i++;
       if( i<j )  data[ j--] =data[i]; 
   } 
   data[i]=temp;
   quickSort(pvector, l, i-1);   quickSort(pvector, i+1, r);
}  

```



### 分配排序



  -- 将排序码，分解 ->若干部分，

   如：十位、个位

  -- 对各部分，分别排序

适用于

​	-- 字符串、整数等，

   具有明显结构特征的排序码

<img src="C:/Users/17363/AppData/Roaming/Typora/typora-user-images/image-20240629001712070.png" alt="image-20240629001712070" style="zoom:33%;" />

### 基数排序

**时间复杂度分析**

  -- 设基数：r，排序码位数：d，排序码个数：n

​    -> 共需执行  d  次“分配+收集”

  -- 每1趟基数排序

​    ->  分配的时间复杂度：O(n)

​    ->  收集的时间复杂度：O(r)

时间复杂度: *O*(d **×**(n+r))

**空间复杂度分析**

  -- 设基数：r，排序码位数：d，排序码个数：n

1. 链接存储，每个记录，增加1个指针

​    -> *O*(n)

2. 所有链式队列的头、尾指针，放在数组Q中

​    -> *O*(r)

空间复杂度:*O*(n+r)

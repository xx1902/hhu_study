# <u>绪论</u>

## 数据结构

**逻辑结构**

* 集合结构  同一集合
* 线性结构  一对一
  * 线性表
  * 栈和队列
  * 字符串
  * 数组
  * 广义表
* 树结构     一对多
* 网结构或网状结构   多对多



**存储结构**

* 顺序存储结构

* 链式存储结构  不要求物理地址连续



**数据类型**

* 数据类型  一个值的集合（int, float）  加上 对这组值的基本操作（加减乘除等等）
* 抽象数据类型  指用户定义的  一组操作的总称
  * 数据对象， 数据关系， 基本操作



## 算法

**特点**

* 有穷性  不是死循环
* 确定性  不会有二义性
* 可行性  不超出范围等等
* 输入  
* 输出

**优劣**

* 正确性
* 可读性
* 健壮性  当数据非法时，能做出正确反映和相应处理
* 高效性  时间 空间



**评价算法的优劣性**

* 时间复杂度

```c
// O(2n - 1)  等比数列求和  1 2 4 8 16 ... n
// 1 * (1 - 2^log n) / (1 - 2) = 2n - 1     -> O(2n - 1)
for(int i = 1; i <= n; i = i * 2)
	for(int j = 1; j <= i; j ++)
```

* 空间复杂度



## c语言

### 指针

```c
#include <stdio.h>

int main(){
    int a = 0;
    int b[3] = {1, 2, 5};
    int *p = &a;
    *p = 2; // 修改地址指向的原数值
    printf("%d\n", a); //    2
    int *f = b; // 指针指向数组地址
    int **ff = &f; // 指向地址的指针
    *ff += 2; // 数组地址加2
    printf("%d", *f); //      5
    return 0;
}
```

指针数组

int* x[10]  长度为10的数组， 每个元素都是指针



### 函数

函数类型  参数表  函数体  返回值



### 结构体



student.id

Pstudent(指针) -> id







# 线性表

线性表**特点**

* **同一性**：所有元素是同一类型
* **有穷性**：线性表由有限个数据元素组成，表长度就是表中数据元素的个数。
* **有序性**：线性表中相邻数据元素之间存在着序偶关系 <a~i~ ,  a~i+1~> 



创建线性表

* 线性表类型
* 数据元素类型
* 下标类型



线性表操作  增删改查、计数、排序



**线性表的存储**

==顺序表==    顺序存数 

* 用一组连续的内存空间、按照逻辑顺序、依次存储线性表的元素 -> 顺序表

```c
struct SeqList{
	int MaxNum; //顺序表有多长 
	int n;  //实际元素数目
	DataType * element; // 存的数据 
}

struct SeqList Var; //定义顺序表 var
typedef struct SeqList Mylist;  //Mylist类型定义
Mylist Var;
Mylist * palist;  //指向循序表的指针

palist -> MaxNum; //查询顺序表的最大空间
palist -> element[i]; // 查询第i个数据
```



操作

查找  插入  删除



==链表==   链式存储

* 用一组非连续的内存单元，分别储存，用指针表示逻辑关系、存储地址  -> 链表



**单链表**

```c
struct Node{
    DataType info;// 数据内容
    PNode link;// 指针
}
```



**循环单列表**
头指针 不存储数据 
第一个头结点 h - > link  或者 t -> link -> link

* 带头结点的单链表	
  * 判断是否为空  clist(尾结点) 是不是指向自己（尾结点和头结点是一个，头部不存储数据）

  * 加数据 尾指针向后移动  新加的数据指向头指针

* 无头结点的循环单链表	
  * 看ppt



**双向列表**

#### 双向循环列表

# 栈和队列

## 栈

特点：

* 一种特殊的线性表，插入和删除都只能在表的同一端进行
* 后进先出，先进后出

**顺序栈**  

**链栈**



## 队列

特点;

* 一种特殊的线性表，只允许在一端进行插入，而在另一端进行删除
* 先进先出，后进后出

环形队列，为了区分空和满 -> 牺牲一个节点空间

* 入队  `q.rear ++;`

* 判断是否为空  头尾指针 是否相等 ` q.front == q.rear`   front(队头在队尾后面)

* 判断是否满    尾指针+1 % 长度 是否等于头指针  `(q.rear + 1) % m == q.front`    rear(队尾在队头后面)

* 返回长度   `(尾 - 头 + m) % m`



链式队列

入队 

* 判断是否为空  空直接加
* 不为空 尾指针指向p
* 更新尾指针

头指针或者尾指针为空  队列为空



**递归**

要素

* 递归模式

* 递归出口



**稀疏矩阵**

存行和列 + 数据





# 树和二叉树

### 特点

树：前驱唯一，后继可能不唯一

结点的度：一个节点的分支个数

**满二叉树**

* 国外  度为2 或为0

* 国内定义 全满

**完全二叉树**

* 最后一层节点都集中在该层的最左边若干位置
* 特点
  * 叶子结点只可能在层次==最大的两层==上出现
  * 如果右节点的层次是l，左节点的层次是l或者l+1


**结点的平衡因子**

* 该结点左，右子树深度之差

**平衡二叉树**

* 所有平衡因子的绝对值都不大于1



**重要性质**

* 第i层至多有2^i-1^个节点
* 深度为k的二叉树至多至多有2^k^ - 1个节点
* 二叉树终端结点为n~0~ 度为2的节点数位n~2~  则==n~0~ = n~2~ + 1==
  * n = n0 + n1 + n2       从节点本身算
  * n = n1 + 2 * n2 + 1   从结点的子节点出发，再加上根节点

* 具有n个节点的完全二叉树的深度为log~2~n + 1



[入栈顺序](https://blog.csdn.net/akenseren/article/details/82149145)次数为n，相应的出栈顺序可以为  ==C^n^~2n~ / (n + 1)==





### **二叉树的遍历**

* 先序遍历
* 中序遍历
* 后序遍历 



**深度优先序列DFS**

栈结构

**非递归算法**   **先根遍历 **

**出栈序列**

* 根节点入栈
* top = 栈顶
  * 若top 非空，记录栈顶元素（输出），弹出栈顶
  * 将top 右 左 孩子进栈（反向先右后左） 
* 重复 2 直至栈空

**指针指向序列**

* 根节点入栈，p指向根节点
* p不为null
  * p进栈，p指向左孩子
* 当栈不空 
  * p 指向右孩子
  * 弹出栈顶（输出），重复2
* 若栈空且p为null， 结束





**广度优先序列BFS**

队列结构

非递归算法

* 根节点进队
* 队不空，访问队头
  * 队头的非空左，右孩子进队
  * 队头出队（输出队头）
* 重复2，直至队空





### 二叉树的实现

**顺序存储**

* 浪费空间
* 适合完全二叉树

**链式存储**





**中序线索二叉树**

* 怎么找前驱
  * 若p->ltag ==1 
    * 前驱为 p -> llink
  * 若p->ltag == 0 p有左子树   找左子树的最右下角
    * 置p=p->llink
    * 重复p=p->rlink，直到 p->rtag==1
* 怎么找后继
  * 若 p-> rtag ==1
    * 后继为 p-> rlink
  * 若p -> rtag ==0 p有右子树  找右子树的最左下角
    * 置 p=p->rlink
    * 重复p=p->llink 直到p->rtag==1;
* 怎么遍历
  * 找中序的第一个节点
  * 访问后继节点
  * 直至后继。。。



### 哈夫曼树

特点:

* 权值越大，离根越近



# 字典

### 顺序表实现

**平均查找长度 ALS**

二分查找  递归 非递归 都会写



### 散列表

函数

如何解决冲突

* 开地址法   向后探查  h=(h+d)%m
* 拉链法 



负载因子 a>0.5  空间占有率大于0.5



* 除余法





### **二叉排序树**

性质：

* 若左子树不空，左子树上所有节点的值均小于它的根节点的值
* 若右子树不空，右子树上所有节点的值均大于它的根节点的值
* 它的左右字数也分别是二叉排序树

删除 

* 叶子节点 直接删除
* 只有一个子树  子树替代父亲
* 有两个子树   子树合并
  * 如果左子树 的 右下角 是父亲的左子树  ==特判==



在二叉树中，==有两个孩子的结点==，其中序后继无左孩子，中序前驱无右孩子



**平衡二叉树（AVL树）**

*  每个结点的左右字数高度之差的绝对值不超过1
*  结点的平衡因子:右子树高度-左子树高度

最小不平衡子树

* 在新插入结点的祖先中，离新结点最近，且平衡因子绝对值>1

四种调整平衡模式

* -- LL型：新结点插入到A的左子树的左子树中；
  * 先修改父亲节点指针
* -- LR型： …………………..左…...的右…...中；
  * LRL
  * LRR
  * LR0
* -- RR型：…………………..右…...的右……中；
* -- RL型：…………………...右…...的左……中；



### B树

**b-树**

特点

* 每个结点至多有m棵子树，m-1个关键码
* 若根不是叶子，至少有两棵子树（由底层分裂生长）
* 除根，至少有m/2（向上取整）个子树，(m/2) - 1个关键码
* 所有的叶子在同一层 -> 是平衡的



**b+树**

* b-树 关键码不重复
* b+树叶子节点包含完整的关键码

* 操作都在叶子节点进行





# 图

## 概念

无向图  (A,D)

有向图 <A,D>



顶点间 邻接

顶点和边 关联



有根图  一个顶点V可以到达所有的顶点

连通图  任意两个顶点都连通

连通分量  极大连通子图

强连通图  强连通分量

带权图



## 图的表示

邻接矩阵

邻接表













# 期中考试

## 绪论

数据类型

* int,等
* 抽象数据类型  有一定行为的抽象类型

数据结构

* 集合
* 线性  线性表，字符串，栈，队列
* 树
* 图

算法

* 有穷性
* 确定性
* 可行性

算法性能

* 时间复杂度
* 空间复杂度

指针

* 传值调用
* 传址调用
* 引用调用



## **线性表**

* 特点
  * 同一性
  * 有序性
  * 有穷性
* 存储
  * 顺序表
  * 链表

**平均查找长度ASL**

$\sum_{i=1}^{n}p_{i}C_{i}$

* pi是查找第i个元素的概率
* 



**顺序表操作**

```c++
struct SeqList{
    int MaxNum;
    int n;
    int* element;
};
```

* 创建空链表
  * 分配空间
  * MaxNum = m
  * n = 0
* 判断表空
  * n == 0 
* 查找元素
  * 遍历 n
* 插入元素
  * 判断表是否还**有空位**
  * 判断下标是否**合法**    p<0    p>n
  * 将第p个元素及之后的 ==从后往前== 往后移动
  * 插入数值
  * ==更新表长== n

* 删除元素
  * 判断下标是否合法  p < 0 || p > palist->n-1
  * p点  ==从前往后== 往前移动
  * 更新表长 n



优点：

1. 存储**密度高**：数据本身所占空间/结点空间；
2. 方便随机存取表中任一元素； （）**访问方便**

缺点：

1. 插入或删除，需依次**移动大量**元素；
2. **预先分配**存储空间 
   1. 可能溢出，
   2. 空间可能长期闲置；





**链表**

> 在数据之外，附加指针，指示逻辑关系、存储地址

```c++
struct Node{
    int info;
    Node* link;
};
```

* 创建空链表
  * llist->link = NULL
* 判断表空
  * llist->link == NULL
* 查找元素
  * p -> info != x
  * 遍历 p = p->link
* 插入元素
  * 申请新节点q  给值
  * q的后继指向要插入p的后继
  * p的后继指向q
* 寻找前驱
  * p1->link != p;
  * 遍历 p1 = p1->link
* 删除元素
  * 找到p的前驱p1
  * p1指向p的后继



优点：

1. **插入或删除**，只需修改指针，无需移动元素；
2. 动态分配存储空间；

缺点：

1. **存储密度**比顺序表低；
2. 不能**随机访问**第i个元素，需顺链查找；





**循环单链表**

>单链表中‘尾结点的指针域’指向头结点 -> 循环单链表
>
>在逻辑上，具有“向前查找”的功能
>
>带头结点  --  不带头结点

```c++
struct Node{
    int info;
    Node* link;
};
```

* 判断尾指针 p->link == clist
* 创建空表
  * 创建节点 指向自己  clist->link = clist
* 判断表是否为空
  * llist->link == clist
* 带头结点 插入节点（尾插）  头结点H
  * 创建新节点p 给值
  * 新节点加入链表  p->link = click->link    （将最后的指针指到开头）
  * 连成环 clist ->link = p
  * ==设置尾指针==  clist = p
* 无头节点 插入节点（空表）   不是空表后和带头结点操作相同  clist指向尾结点
  * 创建新节点p 给值
  * clist = p  
  * clist -> link = clist  设置循环



**双链表**

> p为了方便查找前驱、后继 -> 双链表    -- 增加指向“前驱”的指针域L

```c++
struct DoubleNode{
    int info;
    DoubleNode* llink;
    DoubleNode* rlink;
};

typedef struct DoubleNode * PDoubleNode; 
struct DoubleList //双链表类型
{ 
    PDoubleNode head;
    PDoubleNode rear; 
};
```

* 删除节点p
  * p的前驱的rlink指向p的后继  p->llink->rlink = p->rlink
  * p的后继的llink指向p的前驱  p->rlink->llink = p->llink
* 插入节点q 在后面   （在前面逻辑相同）
  * 创建新节点q 给值
  * 新节点q的后继 指向p的后继   q->rinlk = p->rlink
  * 新节点q的前驱 指向p             q->llink = p
  * p后继的前驱指向 新节点q      p->rlink->llink = q
  * p的后继指向新节点 	           p->rlink = q





**循环双链表**

> 带头结点    --- 不带头结点

* 循环双链表性质: (p指向任意结点)
  * p == p->rlink->llink 且 p == p->llink->rlink





**Josephus问题  约瑟夫**

1) n个人围坐在一个圆桌周围，
2) 第s个人报1，依次报数，数到m的人出列，
3) 出列者的下一位报1，同理，数到m的人出列，
4) 重复3)，直到所有人都出列；

复杂度

* 顺序表
  * 按序号随机存取，*O*(1)
  * 删除结点，需移动其后续元素，*O*(n)
  * 最后1个与第1个元素“逻辑相邻”。下标 j 对“数组长度” 取余，即j=(j+1)%n，实现循环。
  * 步骤
    * 初始化顺序表：建空表，并插入n个结点；表长n、起始数的下标 s1 = s - 1、步长m；
    * 将要出列元素temp的下标：==t=(s1+m-1) %n== ；
    * 删除temp à新的顺序表，==新表长n=n-1==，  ->  用循环代替
    * 新表==是否为空==? 是则完成；否则，新的起始数数下标 ==s1= t== ;  返回2)；

* 链表
  * 按序号m查找 -- 从链首开始遍历，*O*(m)
  * 删除结点，只需修改指针，*O*(1)
  * 需知道被删除结点的前驱
  * 步骤
    * 建立, 并初始化循环单链表clist;
    * 依据s，”计数查找” 起始结点p及其前驱pre;
    * 链表中==是否仅剩1个==结点?  是，则删除该**结点**，退出;
    * 从p开始, “计数查找”第m个结点p及其前驱pre;
    * 从链表中删除p指向的结点， p指向被删结点的下一个结点；返回3)继续，





## 栈和队列

> 操作位置受限的线性表；  -- 插入、删除位置受限；

### **栈**

>p一种特殊的线性表，插入和删除都只能在表的**同一端**进行

特点

* 先进后出， 后进先出



**顺序表**

```c++
struct SeqStack{  
    int MaxNum;  
    int top;    //栈顶元素的下标，top<=MaxNum-1
    int* s;     //s指向顺序栈的第1个单元
};
typedef struct SeqSack * PSeqStack; //顺序栈的指针类型
```

* 创建空栈
  * 分配空间
  * MaxNum = m
  * top = -1
* 判断是否为空
  * pastack -> top == -1
* 进栈 push
  * 先top增加        pastack->top = pastack->top + 1
  * 给栈顶赋值
* 出栈 pop
  * 直接修改top   pastack->top = pastack->top - 1
* 取栈顶元素
  * 先==判空== 
  * 取元素 return pastack->s[pastack->top]



**顺序栈的共享技术**

* 为每个新栈，预先申请MaxNum个空间 -> 可能，空间浪费
* (两个)顺序栈的共享技术： 利用“**栈底不变，而栈顶动态变化**”的特性
* ->  两个栈，共享一维数组S[M]，两个栈的栈底，分在S的两端, 下标为0, M-1

```c++
struct dseqstack{
    int MaxNum; 
    int top[2]; 
    int* s; 
}; 
typedef struct dseqstack* PdSeqStack; 

```

* 建空栈
  * 分配空间
  * MaxNum = m
  * pstack->top[0] = -1；
  * pstack->top[1] = M;

* 进栈
* 出栈
  * 一个是top--
  * 一个是top++



**链栈**

```c++
struct Node{
    int info;
    Node* link;
};
typedef struct Node * PNode;


struct LinkStack //链栈类型定义
{ 
    Node* top; 
};
typedef struct LinkStack * PLinkStack;
//强调栈顶top是栈的一个属性
```

* 创建空栈
  * 分配空间 
  * plstack -> top = NULL
* 判断栈是否为空
  * plstack -> top == NULL
* 进栈
  * 创建新节点 给值
  * 将==新节点指向之栈顶==p->link = plstack->top
  * ==指向新栈顶==   plstack -> top = p 
* 出栈
  * 先==判空==
  * 指向栈顶  p = plstack->top 
  * 删除栈顶  ==将top指向栈顶的下一个节点==   plstack->top = plstack->top->link
* 取栈顶元素
  * 判空
  * return plstack->top->info



**栈的应用**

**1.栈与数制转换**

> 数制转换：将十进制数N转换为m进制数
>
> 
>
> 第1次mod求出最低位,而一般要求从高位输出,
>
> 即，先进后出 -> 栈

```c++
   void conversion(int N, int m)
   { Pstack S = createEmptyStack();
      while(N) { push_stack(S, N%m); ////余数进栈
                       N=N/m; } // 整除
       while( ! isEmptyStack(S)) ////当栈不空
                   { printf(“%d”, top_stack(S));
                     pop_stack(S);}
    }
```

**2.栈与括号匹配(纠错)**

> 表达式中有三种括号(), [ ], { }，检查三种括号   层层嵌套正确与否？
>
> 正确的特征：从左向右遍历，若碰到右括号，
>
> ​           则一定已经历与其配对的左括号；
>
> ​           且走到最后，左括号不多余；

步骤

* 创建空栈
* 左括号 入栈
* 右括号
  * 栈空  -> 不合法
  * 匹配栈顶  -> 弹出栈顶
  * 不匹配栈顶  -> 不合法
* 读取完
  * 栈不空 -> 不合法（左括号多余）
  * 空 ->合法

**3.栈与表达式计算**

> 计算带括号的算术表达式，并假设：
>
> 1)加、减、乘、除 4种运算符
>
> 2)操作数为int型常数
>
> 3)界定符包含： 括号 和 表达式结束符#

运算规则：

1) 先乘除、后加减
2) 从左算到右
3) 先括号内，后括号外

步骤

* 建两个栈    一个数栈   一个符号栈
* 读入字符
  * 操作数   进数栈
  * 运算符   与栈顶比较优先级
    * 新运算符的 优先级更高   -> 入栈
    * 新运算符的 优先级低  
      * 运算符出栈
      * 数栈 出栈两次   计算
      * 将结果 压入数栈
      * 继续比较（）
    * 优先级相等   计算
    * 有括号 
      * （  不动
      *  ） 算到左括号





### **队列**

> 一种特殊的线性表，只允许在一端进行插入，而在另一端进行删除

特点

* 先进先出，后进后出



**顺序队列**

```c++
struct SeqQueue{  
    int MaxNum;  
    int f, r;  //f:队列头, r:实际队尾的下一个位置
    int * q;  //q指向队列数组 
};
typedef struct SeqQueue * PSeqQueue;//PSeqQueue: 顺序队列指针类型
```

创建空队列

* 申请队列数组空间

* 右端点是 0 paq->r = 0
* 队列没元素 （左端点等于右端点） paq->f=paq->r

假溢出  ->   数组前面没有数据



**循环队列**

>-- (逻辑上)规定：
>
>paq->q[0]是paq->q[M-1]的下一个元素

会导致paq->r == paq->f    即，==队满与队空混淆==

为了区分空和满   ->  牺牲1个节点空间，

当队列中==有M-1个元素==即队满，

* 队满的条件：(paq->r+1) %M == paq->f，==（记得模M）==

* 空队的条件仍是：paq->r==paq->f

**操作**

* 创建空队列
  * 申请空间
  * MaxNum = m
  * paq->r=0, paq->f=0
* 判空 
  * paq->r == paq->f
* 判满
  * (paq->r+1) %M == paq->f
* 入队
  * ==先判满==
  * 在 r 处插入值 paq->q[paq->r] = x
  * 将r 后移  paq->r = (paq->r + 1) % M    ==注意模M==(下标做加法均要%M)
* 出队
  * ==判空==
  * ==将f 后移== paq->f = (paq>f + 1) % M
* 取队头元素
  * 判空
  * 返回队头  paq->q[paq->f]



**链表队列**

```c++
struct Node;
typedef struct Node * PNode;
struct Node
{  int  info;
   PNode  link;
};

struct LinkQueue{//链式队列类型
    PNode f; //头指针：指向队头
    PNode r; //尾指针：指向队尾 
};
typedef struct LinkQueue * PLinkQueue;
PLinkQueue plq; //plp: 指向链式队列的指针
```

* 创建空链式队列
  * 申请空间
  * 队头 ，队尾 设置为空   plq -> f = NULL,   plq -> r = NULL
* 判断队列是否为空
  * plq -> f == NULL,   plq -> r == NULL
* 入队（队尾插入）
  * 创建新节点  给值
  * ==判断队头 是否有值==
    * 没值  指向新节点（空队） plq->f = p
    * 有值  将==尾指针指向新节点==   pld->r->link=p
  * 修改尾指针 pld->r = p
* 删除队头
  * 判空
  * 将p赋值 为队头 p=plq->f
  * 删除队头 
    * ==如果只有一个节点==  都删除
    * 不止一个  pdq->f = p->link
* 取队头元素
  * 判空
  * return plq->f->info



**应用**

**打印杨辉三角**

* 用第n行计算第n+1行，

* 1个数，用完即出队；

* 新数出现就入队



### **递归和稀疏矩阵**

**递归**

> 是指在定义自身的同时，又出现了对自身的调用。 
>
>   --直接递归: 函数在其定义体内直接调用自己；
>
>   --间接递归: 函数经过一系列的中间调用语句， 通过其它函数间接调用自己；

**应用**

**1.阶乘问题**

```c++
 long fact(long n)
 { if (n == 0)
       return 1;
   else
       return n * fact(n-1);
  }
```

**2.汉诺塔问题**

```c++
void Hanoi( n, A, B, C) //将n个盘子从A移动到C

{  if (n == 1) // 递归出口
       Move(A, C); 
   else
   {   Hanoi(n-1, A, C, B);  // 如果有多个  先将上面的n-1个暂时移动到B
       Move(A, C);             // 将A上的剩下的最大的一个移动到C
       Hanoi(n-1, B, A, C); // 将B上的递归移动到C
    }
}
```





**稀疏矩阵**

> • 定义：设m×n的矩阵A中有k个非零元素，
>
> ​       又设k远小于m×n（记为k<< m×n ），  
>
> ​        则称A为稀疏矩阵

三元组表示法

* 按先行后列下标升序，存放在数组中

```c++
struct triMatrix
{   int m, n;  //行数，列数
    int k;       //非0个数 
    struct Tridata * ele; //三元组
};

struct Tridata
{   int row, col;  //行，列下标
    int value; //值
};
```

**打印原始矩阵**

```c++
//打印原始矩阵
int main(){
    struct triMatrix Ma;
    int index=0;  //三元组tri上的游历下标
    for(int i = 0; i < Ma.m; i ++){
        for(int j = 0; j < Ma.n; j ++){   
            if(i == Ma.ele[index].row && j == Ma.ele[index].col)
                printf("%d", Ma.ele[ index++].value);
            else    printf("%d", 0);
        }
    }

    return 0;
}
```

**转置**

不是简单的对调行和列的数  ->  ==要有顺序==

* 扫描1遍三元组数组，得到原矩阵M中的1列；
  * 例：找第0列，转为第0行；
  *   找第1列，转为第1行；
  * ……
  * 找第n-1列，…第n-1行；

* 外层for，i<n列
* 内层for，j<length(Ma)
* 用于寻找第i列

```c++
index=0; //Mb中的游历下标
for(i=0; i<Ma.n; i++)
{    for(j=0; j<Ma.k; j++) //数组长度Ma.k
      {    if ( Ma.ele[j].col == i ) //寻找第i列
            {   Mb.ele[index].row = Ma.ele[j].col;
                 Mb.ele[index].col = Ma.ele[j].row;
                 Mb.ele[index++].value = Ma.ele[j].value;
            }
      }
      if(index >=Ma.k)   break; //若Mb已填满，则结束
}
```







## 二叉树与树

>  树型结构：唯一前驱，后继可以不唯一



### **二叉树**

> • 结点的度：一个结点的分枝个数；
>
> • 父亲结点：存在分枝的结点；
>
> • 子结点(儿子结点)：由分枝而产生的结点；

定义

* 有限个、有层次分枝关系的结点组成的集合；   ==可以是空集==。

非空二叉树（递归定义）

* 一个根结点，及其两棵互不相交的子树
* 左子树、右子树都是二叉树；

特点

* ==除树根结点==外，所有结点只有1个前驱；
* 任何结点的后继≤ 2个；
* 二叉树的深度或高度
  * 算路径长度   ->  节点数-1
  * **根节点是第0层**
  * 从树根R到K的路径：R, A, C, G, K，长度为4。

**性质**

* 设二叉树的层数编号从0开始，则非空二叉树的i层上，至多有$2^i$个结点

* 高度为k的二叉树

  * 最多有$2^{k+1}-1$个结点(k≥0)
  * 最少有k+1个结点

* 任何非空二叉树，设有叶子结点(度为0)n0个、 度为1的结点n1个、度为2的结点n2个

  * ==n2= n0 -1==    分别从节点数 和 边数-> 边数+1=节点数

* 有n个结点的完全二叉树，其高度k为  log2n（下取整）

* 有n ≥1个结点的二叉树，其高度(深度)

  - 最大值(结点最大度为1)：n-1

  - 最小值(设计成完全二叉树)：log2n 下取整



**特殊的二叉树**

**满二叉树**

定义

* 国际定义
  * 任意结点，要么度为0，要么度为2；
  * 即：结点或者是叶子，或者有两棵非空子树
* 国内定义   **(国内考试)**
  * p除最后一层无子结点外，每层上的任意结点都有两个子结点；
  * 即：除叶子外, 其他结点都有2个孩子，且叶子结点都在最后一层；
  * 若二叉树高度(深度)k一定，结点最多的二叉树是满二叉树， ==结点数目==：$2^{k+1}-1$



**完全二叉树**

* 只允许==最后两层结点==的度数小于2；
  * 最后一层 依旧都是0（叶子节点）
  * 倒数第二层 可能为 0 1 2  （可能存在叶子节点）
* 最后一层结点都集中在该层==最左边==的若干位置
* 完全二叉树、满二叉树的==结点序号一一对应==



**扩充二叉树**

* 将二叉树的所有结点，都扩充成度为2的分枝结点
  * 原来度为0，-> 增加2个分枝、2个新结点；
  * 原来度为1，-> 增加1个分枝、1个新结点；
  * 原来度为2，-> 保持；
* 扩充二叉树中，所有叶子都是外部结点
  * 内部结点：原有结点；
  * 外部结点：新增结点；
* 外部路径长度**E**：
  * 从根到每个外部结点的路径长度之和；
*  内部路径长度**I**：
  * 从根到每个内部结点的路径长度之和；



**平衡二叉树**

* 结点的**平衡因子**：该结点的左、右子树深度之差；
* 所有结点平衡因子的绝对值都不大于1；
* 递归定义
  * 是一棵空树
  * 左右子树都是平衡二叉树，并且，左、右子树高度差的绝对值不大于1





**二叉树的遍历**

深度优先遍历

* 先序 DLR
  * 递归过程： 
    * (1) 访问根；
    * (2) 按“先根”遍历左子树；
    * (3) 按“先根”遍历右子树；
* 中序 LDR
* 后序 LRD



**反推二叉树**

* -- 递归过程：

  (1) 在后根序列中找根(最右为根)；

  (2) 在中根序列中，

     根的左侧为其左子树，右侧为其右子树

* -- 递归过程：

  (1) 在后根序列中找根(最右为根)；

  (2) 在中根序列中，

     根的左侧为其左子树，右侧为其右子树；





**非递归遍历二叉树**

**先根递归**

(1) 访问根；

(2) “先根”遍历左子树；

(3) “先根”遍历右子树；

访问根之后，不能‘忘记’根；交代‘左、右子树’之后，才能‘忘记’；



**栈实现 出栈访问**

* 根结点，入栈1次，
* 访问栈顶、退栈，并让被访问结点的==右、左孩子进栈==；注意先右后左
  * top非空
* 重复2，直到栈空

**栈实现 入栈访问**

* 置树根为当前结点p, 
* 若p≠Null，==访问p==，p进栈，p=p的左孩子；
* 重复2), 直到p为Null；
* 当栈不空，p=栈顶的右孩子， ==栈顶退栈==，返回2)；
* 若栈空且p为Null ，结束。



**中跟遍历**

* 置树根为当前结点p，
* 若p≠Null， p进栈，p=p的左孩子；
* 重复2)，直到p为Null；
* 当栈不空，p=栈顶的右孩子，==访问栈顶==，退栈，返回2)；
* 若栈空且p为Null ，结束



**后跟遍历**

* p指向树根，

* 若p≠Null,  p进栈，p=p的左孩子；
* 重复2),直到p为Null；
* 当栈不空，求助栈顶，==即p=栈顶==；
  * 栈顶无右孩子，或右孩子刚被访问， -> ==访问栈顶==，退栈，令p=Null(再次求助栈顶) ==重复4）==
  * 否则，p=p的右孩子  ==重复2）==

* 若栈空且p为Null ，结束





**广度优先遍历**

**队列实现**

* 根结点进队；
* 当队不空，访问队头，
  * 队头的==非空左、右孩子==进队
  * 队头出队；
* 重复2)直到队空；

**如何判断是否为完全二叉树**

* 遍历过程中(初始化flag=0)：
* 第1次遇到leftChild或rightChild为空，置flag=1；
* 继续，若后续结点有孩子非空，且flag为1，则不是完全二叉树；





### **二叉树实现**

**顺序表示**

将完全二叉树，按‘广度优先遍历’的顺序，进行顺序存储：

基本操作：

*  求结点的左孩子、右孩子、父亲、左右兄弟；
  * ==复杂度？O(1)==

缺点：浪费空间





**链接表示**

二叉链表链表 -- **左右孩子(左右指针)表示法**：

```c++
struct BinTreeNode 
{   DataType  info; 
     PBinTreeNode  llink;     
     PBinTreeNode  rlink; }; 
typedef struct BinTreeNode * BinTree; 
```

* 创建二叉树

  * 扩充二叉树的先序序列:`ABD$$$CE$G$$FH$$I$$`
  * 若节点为空  return NULL
  * 否则 申请空间
    * 给值
    * 创建左右子树 p->llink = create_BTree();   p->rlink = create_BTree(); 

* 求叶节点数

  * 递归 算 左右子树的 叶子数

  ```c++
     int leaf(BinTree t)
         若t空，          return 0;
         若t是叶子，   return 1;
         //否则，说明t至少有一颗子树
         return(leaf(t->llink) + leaf(t->rlink) );
     }
  ```



n个结点的二叉树(二叉链表)，有几个空指针？

* ==n+1==个     2n个指针节点 - （n-1）个边



**线索二叉树**

>空的llink存储：结点在某遍历序列中的前驱；
>
>空的rlink存储：结点在某遍历序列中的后继；

中序线索，总是向上指

加入==标志位==：ltag,  rtag -> 新的结点结构

```c++
struct ThrTreeNode
 {     DataType info; 
       PThrTreeNode  llink, rlink; 
       int ltag, rtag; }
typedef struct ThrTreeNode * ThrTree; 
```

意义

* 方便寻找“中序序列”中的前驱与后继，提高遍历速度；
* 非递中序归遍历，不需要栈；

**找任意节点p的中序前驱**

* 若p->ltag==1, 

  *  前驱为：p->llink;

*  若p->ltag==0 (则p有左孩子), 

  * 前驱为：p的左子树的==“最右下”==结点；

  * 做法
    * 置p=p->llink,
    * 重复p=p->rlink，直到 p->rtag==1;
    * 进入p的左子树，沿rlink，找第1个没有右孩子的结点；

  ```c++
  if(p->ltag==1) 
        return (p->llink); 
  if(p->ltag==0)
        p=p->llink; 
        while(p->rtag==0)
               p=p->rlink; 
        return p; 
  }
  ```

**找任意结点p的中序后继**

* 同上 找最左下





### **应用**

堆

优先队列

**哈夫曼树**

> 等长编码
>
> * 码长为n à可以表示2n个不同的字符
>
> 不等长编码
>
> * 传送码长尽量短 -> 高频词汇的编码尽量短；
> * 译码结果唯一  -> 前缀编码
>   * --任一编码不是其他编码的前缀(开始部分)； 

特点

* 权值越大，离根越近；
* 带权结点是 ==叶子==（外部结点）

定义

* 将m个带权结点作为叶子，构造二叉树， 其中带权路径长度最小的为哈夫曼树

* Ø 叶子的带权路径长度：

    权值×路长：wi ×Li；

* Ø 树的带==权路径长度（WPL）==：

  		叶子带权路长之和：求和(wi ×Li)

建立

* 带权结点独立成树
* 合并根最小的两棵, 成新树 ， 新树根的权=左+右子权值
* 重复2)，直到只剩1棵树

```c++
struct HtNode
{   int ww;
     int parent, lindex, rindex;
}//哈夫曼树的结点结构
```





### 树

> 有限个结点及其关系的集合，可以为空，否则满足：
>
> (1)有且仅有1个根；
>
> (2)除根外，
>
> ​    其余结点分为若干不相交的集合
>
> ​    T1, T2, ……, Tm，
>
>    每个集合是1棵树，称为根的子树。

• 结点的度：该结点的孩子个数；

• 树的度：树中结点度的最大值；

• 兄弟：有共同的父结点；

• 无序树：兄弟间无左右次序；

• 有序树：兄弟分左右；

• 长子：最左子结点；

• 次子：长子的右邻；

• 左、右兄弟



**遍历**

先根遍历

- 访问根结点D

- 从左到右先根遍历所有子树

步骤

* -- 沿长子方向，边访问边进栈，

    走不动时（即栈顶没有孩子时），

    去栈顶的右兄弟处，栈顶退栈；

后根遍历

- 从左到右后根遍历所有子树

- 访问根结点D

步骤

* 置树根为当前结点p, 
* 当p≠Null, p进栈, p=p的长子；
  *  重复, 直到p==Null；
* 若栈不空，==访问栈顶，==
  * p=栈顶的右兄弟，
  * 栈顶退栈，返回2)；
* 若栈空且p==Null，结束。



**树的广度优先遍历**

* 根结点进队；
* 当队不空，访问队头，
  * 队头的孩子==从左至右依次进队==，
  * 队头出队；

* 重复2)直到队空；



**树的实现**

> 需反映的关系：
>
> 1. 父亲--孩子；
> 2. 左--右兄弟；

**1.父亲数组表示法**

  (双亲表示法，父指针表示法)

```c++
struct ParTreeNode
{ DataType info; //结点数据信息
   int parent;  }; //父亲的下标

struct parTree
 { int MaxNum, n;   
   struct ParTreeNode * nodelist;};
Typedef struct ParTree *PParTree; 
```

直接存储：父亲--孩子关系，

**兄弟之间的‘左右关系’，如何体现？**

* 按照某种遍历顺序，依次存放各结点。

**找p结点的右兄弟**

* 先根顺序 先判断p的值是否合法
* 右兄弟的节点比 p大     ==遍历 p+1 ~ n==
  * 直至父亲节点相同

**找p节点的长子**

* 先根顺序  一定在p的==下一位置==
* 判断下一个 结点的父节点是否为 p



**2.子表表示法 (孩子链表表示法)**

* 子表：一个结点的所有孩子、按从左至右的顺序组成1个单链表；

* 结点表：是一个顺序表，长度为n，每个元素的结构为 info 和 chlidren

可以按照先根顺序，也可以按照广度搜索

```c++
struct EdgeNode//子表(单链表)中结点结构
 { int nodePosition; 
   struct EdgeNode * link; };

struct ChiTreeNode//结点表中元素结构
 { DataType info; 
   struct EdgeNode * children;};

struct ChiTree//树的类型（顺序表结构）
{  int MaxNum;
   int root; 
   int n; 
   struct ChiTreeNode * nodelist;}
typedef struct ChiTree * PChiTree;
```

小结：（对于下标为p的结点）

* 方便找：长子、所有孩子；
* 找p的父亲？
  - 依次检查各子表，若p在其中，返回“该子表所隶属的结点表中元素”；
  - 遍历子表 i  遍历结点表 找到 return i

* 找p的右兄弟？
  - 依次检查各子表，若p在其中，则该子表中，p的下一个结点即是。
  - 遍历子表 i  遍历节点表 找到 return v->link->nodePosition



**3.长子-兄弟表示法**

* 指针 lchild指向长子
* info数据信息
* 指针 rsibling指向右兄弟

```c++
struct CSNode;
typedef  struct CSNode * PCSNode;
struct CSNode
 { Datatype info; 
   PCSNode lchild;
   PCSNode rsibling;}
```

小结：（对于指针p所指结点） 

* 找长子：p->lchild;

* 找右兄弟：p->rsibling;

* 找p的所有子结点：

  * q=p->lchild;

      while(q!=null)

      {访问q;

       q=q->rsibling;}

* 找父亲？

  * --遍历树，判断结点孩子是否是p

# 绪论

## 数据结构

**逻辑结构**

* 集合结构  同一集合
* 线性结构  一对一
  * 线性表
  * 栈和队列
  * 字符串
  * 数组
  * 广义表
* 树结构     一对多
* 网结构或网状结构   多对多



**存储结构**

* 顺序存储结构

* 链式存储结构  不要求物理地址连续



**数据类型**

* 数据类型  一个值的集合（int, float）  加上 对这组值的基本操作（加减乘除等等）
* 抽象数据类型  指用户定义的  一组操作的总称
  * 数据对象， 数据关系， 基本操作



## 算法

**特点**

* 有穷性  不是死循环
* 确定性  不会有二义性
* 可行性  不超出范围等等
* 输入  
* 输出

**优劣**

* 正确性
* 可读性
* 健壮性  当数据非法时，能做出正确反映和相应处理
* 高效性  时间 空间



**评价算法的优劣性**

* 时间复杂度

```c
// O(2n - 1)  等比数列求和  1 2 4 8 16 ... n
// 1 * (1 - 2^log n) / (1 - 2) = 2n - 1     -> O(2n - 1)
for(int i = 1; i <= n; i = i * 2)
	for(int j = 1; j <= i; j ++)
```

* 空间复杂度



## c语言

### 指针

```c
#include <stdio.h>

int main(){
    int a = 0;
    int b[3] = {1, 2, 5};
    int *p = &a;
    *p = 2; // 修改地址指向的原数值
    printf("%d\n", a); //    2
    int *f = b; // 指针指向数组地址
    int **ff = &f; // 指向地址的指针
    *ff += 2; // 数组地址加2
    printf("%d", *f); //      5
    return 0;
}
```

指针数组

int* x[10]  长度为10的数组， 每个元素都是指针



### 函数

函数类型  参数表  函数体  返回值



### 结构体



student.id

Pstudent(指针) -> id







# 线性表

线性表**特点**

* **同一性**：所有元素是同一类型
* **有穷性**：线性表由有限个数据元素组成，表长度就是表中数据元素的个数。
* **有序性**：线性表中相邻数据元素之间存在着序偶关系 <a~i~ ,  a~i+1~> 



创建线性表

* 线性表类型
* 数据元素类型
* 下标类型



线性表操作  增删改查、计数、排序



**线性表的存储**

==顺序表==    顺序存数 

* 用一组连续的内存空间、按照逻辑顺序、依次存储线性表的元素 -> 顺序表

```c
struct SeqList{
	int MaxNum; //顺序表有多长 
	int n;  //实际元素数目
	DataType * element; // 存的数据 
}

struct SeqList Var; //定义顺序表 var
typedef struct SeqList Mylist;  //Mylist类型定义
Mylist Var;
Mylist * palist;  //指向循序表的指针

palist -> MaxNum; //查询顺序表的最大空间
palist -> element[i]; // 查询第i个数据
```



操作

查找  插入  删除



==链表==   链式存储

* 用一组非连续的内存单元，分别储存，用指针表示逻辑关系、存储地址  -> 链表



**单链表**

```c
struct Node{
    DataType info;// 数据内容
    PNode link;// 指针
}
```



**循环单列表**
头指针 不存储数据 
第一个头结点 h - > link  或者 t -> link -> link

* 带头结点的单链表	
  * 判断是否为空  clist(尾结点) 是不是指向自己（尾结点和头结点是一个，头部不存储数据）

  * 加数据 尾指针向后移动  新加的数据指向头指针

* 无头结点的循环单链表	
  * 看ppt



**双向列表**

#### 双向循环列表

# 栈和队列

## 栈

特点：

* 一种特殊的线性表，插入和删除都只能在表的同一端进行
* 后进先出，先进后出

**顺序栈**  

**链栈**



## 队列

特点;

* 一种特殊的线性表，只允许在一端进行插入，而在另一端进行删除
* 先进先出，后进后出

环形队列，为了区分空和满 -> 牺牲一个节点空间

* 入队  `q.rear ++;`

* 判断是否为空  头尾指针 是否相等 ` q.front == q.rear`   front(队头在队尾后面)

* 判断是否满    尾指针+1 % 长度 是否等于头指针  `(q.rear + 1) % m == q.front`    rear(队尾在队头后面)

* 返回长度   `(尾 - 头 + m) % m`



链式队列

入队 

* 判断是否为空  空直接加
* 不为空 尾指针指向p
* 更新尾指针

头指针或者尾指针为空  队列为空



**递归**

要素

* 递归模式

* 递归出口



**稀疏矩阵**

存行和列 + 数据





# 树和二叉树

### 特点

树：前驱唯一，后继可能不唯一

结点的度：一个节点的分支个数

**满二叉树**

* 国外  度为2 或为0

* 国内定义 全满

**完全二叉树**

* 最后一层节点都集中在该层的最左边若干位置
* 特点
  * 叶子结点只可能在层次==最大的两层==上出现
  * 如果右节点的层次是l，左节点的层次是l或者l+1


**结点的平衡因子**

* 该结点左，右子树深度之差

**平衡二叉树**

* 所有平衡因子的绝对值都不大于1



**重要性质**

* 第i层至多有2^i-1^个节点
* 深度为k的二叉树至多至多有2^k^ - 1个节点
* 二叉树终端结点为n~0~ 度为2的节点数位n~2~  则==n~0~ = n~2~ + 1==
  * n = n0 + n1 + n2       从节点本身算
  * n = n1 + 2 * n2 + 1   从结点的子节点出发，再加上根节点

* 具有n个节点的完全二叉树的深度为log~2~n + 1



[入栈顺序](https://blog.csdn.net/akenseren/article/details/82149145)次数为n，相应的出栈顺序可以为  ==C^n^~2n~ / (n + 1)==





### **二叉树的遍历**

* 先序遍历
* 中序遍历
* 后序遍历 



**深度优先序列DFS**

栈结构

**非递归算法**   **先根遍历 **

**出栈序列**

* 根节点入栈
* top = 栈顶
  * 若top 非空，记录栈顶元素（输出），弹出栈顶
  * 将top 右 左 孩子进栈（反向先右后左） 
* 重复 2 直至栈空

**指针指向序列**

* 根节点入栈，p指向根节点
* p不为null
  * p进栈，p指向左孩子
* 当栈不空 
  * p 指向右孩子
  * 弹出栈顶（输出），重复2
* 若栈空且p为null， 结束





**广度优先序列BFS**

队列结构

非递归算法

* 根节点进队
* 队不空，访问队头
  * 队头的非空左，右孩子进队
  * 队头出队（输出队头）
* 重复2，直至队空





### 二叉树的实现

**顺序存储**

* 浪费空间
* 适合完全二叉树

**链式存储**





**中序线索二叉树**

* 怎么找前驱
  * 若p->ltag ==1 
    * 前驱为 p -> llink
  * 若p->ltag == 0 p有左子树   找左子树的最右下角
    * 置p=p->llink
    * 重复p=p->rlink，直到 p->rtag==1
* 怎么找后继
  * 若 p-> rtag ==1
    * 后继为 p-> rlink
  * 若p -> rtag ==0 p有右子树  找右子树的最左下角
    * 置 p=p->rlink
    * 重复p=p->llink 直到p->rtag==1;
* 怎么遍历
  * 找中序的第一个节点
  * 访问后继节点
  * 直至后继。。。



### 哈夫曼树

特点:

* 权值越大，离根越近



# 字典

### 顺序表实现

**平均查找长度 ALS**

二分查找  递归 非递归 都会写



### 散列表

函数

如何解决冲突

* 开地址法   向后探查  h=(h+d)%m
* 拉链法 



负载因子 a>0.5  空间占有率大于0.5



* 除余法





**二叉排序树**

性质：

* 若左子树不空，左子树上所有节点的值均小于它的根节点的值
* 若右子树不空，右子树上所有节点的值均大于它的根节点的值
* 它的左右字数也分别是二叉排序树

删除 

* 叶子节点 直接删除
* 只有一个子树  子树替代父亲
* 有两个子树   子树合并
  * 如果左子树 的 右下角 是父亲的左子树  ==特判==



在二叉树中，==有两个孩子的结点==，其中序后继无左孩子，中序前驱无右孩子



11

# 计算机系统概述

* 低/高电平 来表示 二进制 0/1  用电信号传递数据（硬件的金属针脚来发送接收二进制数据）

* 计算机系统
  * 硬件
  * 软件
    * 系统软件   Eg：操作系统、数据库管理系统（DBMS）、标准程序库、网络软件、语言处理软件、服务程序
    * 应用软件   Eg：抖音等

## 计算机发展历程

### 硬件的发展

* 第一台电子计算机   ENIAC(1946)  
  * 顾问  冯诺依曼  
  * 逻辑原件 -> ==电子管== 1.8w个
* ==电子管时代== 1946 - 1957
  * 体积超大、耗电量大
  * 几千到几万 次/秒   
  * 使用机器语言编程  
  * 外存：穿孔卡片、纸带     有孔表示0 没孔表示1       bug -> 虫子
* ==晶体管时代== 1958 - 1964
  * 体积、功耗降低
  * 几万到几十万 次/秒
  * 高级编程语言 -> FORTRAN
  * 外存：磁带
  * 操作系统雏形
* ==中小规模集成电路时代== 1964 - 1971
  * 将元件集成在基片上
  * 几十万到几百万 次/秒
  * 高级语言迅速发展
  * 有了分时操作系统    主要用于科学计算
* ==大规模、超大规模集成电路时代==
  * 出现“微处理器”CPU
  * 个人计算机（PC）萌芽





**CISC**是复杂指令集计算机 -> **Intel x86**

* 可以完成复杂的操作

* 硬件的设计和实现会非常复杂，而且指令执行速度较慢

**RISC**是精简指令集计算机 -> **ARM**和**MIPS** 移动设备 嵌入式系统

* 指令集非常精简，每个指令只执行一种操作，硬件设计简单
* 不能完成复杂的操作，程序员编写代码时需要编写更多的指令



==机器字长：== 计算机一次整数预算能处理的二进制位数

###  软件的发展

* 机器语言
* 编程语言

### 发展趋势

* 更微型、多用途
* 更巨型、超高速



## 计算机软件

### 程序（代码）及数据

* 机器可执行
* 分为系统程序、应用程序等
* 语言的演变

### 文档

* 计算机不可执行（给人看的

### 软件结构

* 结构化程序、面向对象程序
* F/S（文件/服务器）、C/S（客户机/服务器）、B/S（浏览器/服务器）

### 软件分类

* 系统软件  OS（操作系统），DBMS（数据管理系统）
* 应用软件
* 机器语言，汇编语言，高级语言

## 计算机硬件的基本组成

### 冯诺依曼机

<img src="C:/Users/17363/AppData/Roaming/Typora/typora-user-images/image-20240304203513427.png" width="500" height="300">

ENIAC  - > 需要手动接线来控制计算

“==储存程序==” 将指令以二进制代码的形式实现输入计算机的主程序   -> 第一台计算机 EDVAC

* 如果指令和数据存放在两个存储器，称为哈佛结构。



==特点== 

* 计算机由**五大部件**组成
  * 存储器、运算器、控制器、输入设备和输出设备（I/O设备）
* 指令和数据以**同等的地位**存于储存器，可按地址寻访
* 指令和数据用**二进制**表示
* 指令由**操作码**和**地址码**组成， 按照**顺序**存放（不按顺序执行）
* 存储程序   指令和数据提前存储在存储器中， 
* 以==运算器==为中心   - > 输入输出的数据传送通过运算器完成
* **采用存储程序控制方式（指令驱动）**

### 现代计算机

<div style="display: flex; justify-content: space-between;">
<img src="C:/Users/17363/AppData/Roaming/Typora/typora-user-images/image-20240304204915722.png" alt="图片描述" width="400" height="300">
<img src="C:/Users/17363/AppData/Roaming/Typora/typora-user-images/image-20240304205658499.png" alt="图片描述" width="500" height="300">
</div>

以==存储器==为中心 

* 主存 （主机里）
* 辅存 （I/O设备）

==CPU== = 运算器 + 控制器   + 寄存器

* CPU和主存储器进行数据交换
  * 参与运算的数据 放在运算器中
  * 指令   放在控制器中 

==主存储器== 和CPU 统称为 **主机**

* **直接** 和输入输出设备 进行数据交换 

==控制器==

* 通过控制线 告诉 运算器接下来进行什么运算
* 控制主存储器的独显
* 控制输入输出设备的启动、停止



==总线==

* 内部总线 CPU内部各部件的连线 -> 高速通道
* 外部总线 CPU与存储器，输入输出设备之间的连线
* 单总线的运算器
* 双总线的运算器

### 主存储器

* ==存储体== 
  * 存放数据 按照地址储存
  * **存储单元**： 存放一串二进制代码
  * **存储字**：存储单元中二进制代码的组合
  * **存储字长**：存储单元中二进制代码的位数  8  16  32  64 bit
  * 存储元：存储电子的原件（电容），每个存1bit
* ==MAR== （Memory Address Register）
  * 储存地址寄存器
  * 位数反映 存储体中**有多少 存储单元**   MAR = 4 -> 共有2^4^个存储单元
* ==MDR== （Memory Data Register）
  * 存储数据寄存器
  * MDR位数 = 存储字长   MDR=16  -> 一个字=16bit
  * 一个**字节** B 8bit 
* ==CPU==
  * 取数据  CPU（提供地址） -> MAR -> 存储体 -> MDR - > CPU
  * 写数据  MAR（地址）、MDR（数据）、写（操作）
* ==高速缓冲存储器== **Cache**
  * 让CPU与主存之间快速地传输数据
* 内存 主存
  * 存储单元：若干二进制位、N×8位、典型8位
  * 字（word）：与机器字长相同，通常N×8位
  * 存储容量：存储单元个数×存储单元大小（字节数）

* 外存 辅存


> 现代 MAR和MDR也可能集成在CPU中

### 运算器

<img src="C:/Users/17363/AppData/Roaming/Typora/typora-user-images/image-20240304213439686.png" alt="图片1描述" width="500" height="300">



==ALU== 核心部件

==寄存器==ACC、MQ、x

机器字长：

* 运算器进行一次二进制数运算的**位数**
* 位数越长、相应地计算精度越高

### 控制器

<img src="C:/Users/17363/AppData/Roaming/Typora/typora-user-images/image-20240304213852545.png" alt="图片1描述" width="500" height="300">

==CU==：核心部件

==寄存器== IR、PC 

**完成一条指令**： 取指令 PC  -> 分析指令 IR  ->  执行指令 CU

CPU区分指令和数据的依据：**指令周期的不同阶段**（取指周期 和 指令执行周期）

* 机器字长和数据总线宽度是8位、16位、32位时，PC分别是+1、+2、+4。



### 输入输出设备

​    输入设备：键盘、鼠标、数字扫描仪等。

​    输出设备：打印机、显示器、绘图仪等。

​    既是输入、又是输出设备：主要是指软盘、硬盘、光盘、磁带、磁盘阵列等外存。

**适配器**：由于主机与I/O设备之间的速度差异



**总线**

定义：总线是一组能为多个部件分时共享的信息传送通路，用来连接多个部件并为之提供信息传输交换服务。

多级：片内总线、系统总线、I/O总线。

* **共享性**：总线所连接的所有部件都可以通过它传递信息。
* **分时性**：在某一个时刻或者时间范围内总线只允许一个部件发送信息到总线上。显然，共享是分时实现的。
* **总线协议**：总线不仅是一组传输线路，同时连接到总线上的所有部件都必须共同遵守一组规则和约定，称为总线协议

## 计算机系统的层次结构

最常见的是从计算机编程语言的角度划分的计算机系统层次结构。

<div style="display: flex; justify-content: space-between;">
<img src="C:/Users/17363/AppData/Roaming/Typora/typora-user-images/image-20240304221933032.png" alt="图片描述" width="400" height="300">
<img src="C:/Users/17363/AppData/Roaming/Typora/typora-user-images/image-20240304222356592.png" alt="图片描述" width="500" height="300">
</div>

> 透明 -- 看不见
>
> 公开透明 -- 看得见

==虚拟机==：通过**配置软件**扩充物理机（硬件/固件实现）

在计算机系统中，==软件和硬件逻辑上是等效的==

**软件硬化** 整数乘除法等改为直接由硬件/固件完成

==固化、固件==将传统的部分软件写入只读存储器ROM中，称为固化 。只读存储器和写入的软件称为**固件**。固件物理形态上是硬件，运行是软件



## 计算机的性能指标

==存储器==

* MAR位数反映存储单元的个数
* MDR位数=存储字节=每个存储单元的大小
* 总容量 = 存储单元个数 x 存储字长 bit
* MAR为32位 MDR为8位 - > 总容量 `2^32^ * 8 bit = 4GB`
* **2^10^ K   2^20^ M   2^30^ G  2^40^ T**

==CPU==

* **cpu主频**：cpu内数字脉冲信号振荡的频率 （执行速度） -> 每秒总共产生的脉冲数
  * 单位：Hz
  * `cpu主频（时钟频率）= 1 / cpu时钟周期`
* **cpu时钟周期**：每个脉冲信号的时间
  * 单位：微秒、纳秒
* **CPI**：执行一条指令所需的时钟周期数
  * 不同的指令，CPI不同，甚至相同的指令，CPI也可能变化
  * `执行一条指令的耗时 = CPI x CPU时钟周期`
* **cpu执行时间**（整个程序的耗时） `= CPU时钟周期 数 /主频 = （指令条数 * CPI) / 主频`
  * 例题：主频1000HZ 100条指令 平均CPI=3   - > 执行时间 100*3/1000 = 0.3s
* **IPS**：每秒执行多少条**指令**
  * `IPS = 主频 / 平均CPI` 理解：每秒总共产生的脉冲数（总操作数） / 平均每次指令需要的操作数
  * **k 10^3^  M 10^6^  G 10^9^  T 10^12^**
* **FLOPE**：每秒执行多少次浮点运算

==系统整体的性能指标==

* **数据通路带宽**：数据总线一次所能并行传送信息的位数 （各硬件部件通过数据总线传输数据）
  * 影响数据传输效率
* **吞吐量**：指系统在**单位时间**内处理请求的数量  bps
  * 请求 -> 一条指令或者一个程序
* **响应时间**：指从用户向计算机发送的一个请求，到系统对该请求做出**响应并获得它**所需要的结果的等待时间
  * 包括 *CPU时间* 与 *等待时间*
* 基准程序（跑分软件）：测量计算机处理速度的一种实用程序
* 利用率：在给定的时间间隔内，系统/部件被实际使用的时间所占的比率
* 处理机字长：常称**机器字长**，指处理机运算中一次能够完成二进制运算的位数，如32位机、64位机
* 总线宽度：一般指CPU中的运算器与**内存储器**之间互连总线完成**一次操作**可传输的二进制位数。
* 存储器容量：存储器中**所有存储单元**（通常是字节）的总数目，通常用KB、MB、GB、TB来表示
* 存储器带宽：**单位时间**内从存储器**读出的**二进制数信息量，一般用B/s（字节/秒）表示。





# 数据的表示和运算

## 进位计数制

> 拼凑法更快

**十进制（D）**

* 任意进制转换为十进制   按照位权相加
* 转化为其他进制   
  * **整数部分**：除以权重 余数为最低位（除权取余） -> 短除法 从下到上
  * **小数部分**：乘以权重 整数为最高位（乘权取整） -> 直到循环或者为0

**二进制（B）**

* 二进制转八进制       **三位一组**，每组转换成对应的八进制位数   整数头部补0， 小数尾部补0
* 二进制转十六进制   **四位一组**， 每组转换成对应的十六进制数

**八进制（O, 0）**

**十六进制（H，0x）**

>  真值和机器数：实际带正负号的数字（人）和计算机把正负号数字化的数（机器）

## BCD码

> 每四个二进制为对应一个十进制的字符  0 - 9（6种冗余）

**8421码**

  **(有权码)**

* 权重为 8 4 2 1  （1010 - 1111）在映射表中没有意义

* 加法超出（有进位） 映射表范围  **+6**（0110）进行修正  -> 因为  9 + 6 = 15

* > 这里加六，原因是 十进制数加法发生了进位，但是二进制（8421码）遵循二进制加法未进行进位，所以这里个位到十位的进位，需要通过手动加六，才能令9之后的8421码发生进位
  >
  > 手算的话建议==直接算整数==然后映射每一位



**余三码** 

* **-> 8421码+(0011)**

* 无权码



**2421码**

* 0 - 4 **首位 为0**  0000 0001 0010 0011 0100
* 5 - 9 **首位 为1**  1011 1100 1101 1110 1111



–**压缩BCD码**：一个字节存放两个十进制数位

• 不浪费空间；

• 直接进位；

–可以用冗余状态中的两种来表示正和负。如8421码中，可以用12（C）表示正号、13（D）表示负号，放在最低数字位之后。

## 数据格式

**纯小数（定点小数）**

  * 由符号位和数值位 （小数点的位置在隐含在符号位后面）   常写[x]~原~= 1.1100000
  * **原码、反码、补码和定点整数一致， 无移码**
    * 原码： 表示范围 ==-(1 - 2^-(n-1)^) ~ 1 - 2^-(n-1)^==
    * 反码： 表示范围 ==-(1 - 2^-(n-1)^) ~ 1 - 2^-(n-1)^==
    * 补码： 表示范围 ==-1 ~ 1 - 2^-(n-1)==
  * 0 1 2 3 ... n 有n+1位

**带符号整数（定点整数）**

* 一个符号位和`n-1`位的数值位 （小数点固定在最低数值位）常写 [x]~原~= 1,0010011
  * 原码  
    * 表示范围 ==-(2^n-1^- 1) ~ 2^n-1^- 1==
    * **真值 0** 有两种形式  -0. +0
    * 原码的**缺点** 符号位不能参与运算
  * 反码 （原码 - > 反码）
    * 正数 不变
    * 负数 符号位不变 数值位取反
  * **补码**
    * 正数不变 负数末尾+1 （反码 -> 补码）  ==数值位不是位权（负数）==
    * 表示范围 ==-2^n-1^~ 2^n-1^- 1==  原码无法表示 -128
    * 加法 按位相加（符号位参与运算），往高进位  
    * 减法 补码转换 ==**全部位**按位取反，末尾+1== 或者  ==从右往左找到第一个1， 这个1 左边**全部位**按位取反==
    * **快速转换原码和补码** （双向转换） ==从右往左找到第一个1， 这个1 左边的所有**数值位**按位取反==
  * 移码
    * 补码的基础上将**符号位取反**， 移码只能用于表示整数
    * 表示范围 ==-2^n-1^~ 2^n-1^- 1== 
    * 移码表示的整数很方便用`硬件电路对比大小`



**无符号数（正整数）**

  * 没有符号位，全是数值位 ，小数点固定在最低数值位
  * 表示范围 ==0 - 2^n^ - 1==
  * 加法： 从最低位开始，按位相加，往更高位进位
  * **减法**：被减数不变，减数 **全部 按位取反、末尾+1**， 减法变加法





**浮点数**

  * IEEE 754浮点数标准格式 
  * 1 + 8 + 23  
  * S E M 符号 阶数 尾数
  * 转换为 十进制
    * 指数e  = E - 127 (01111111)
    * 尾数1.M

  * 转换为 IEEE754 32位
    * 指数e  = E + 127 (01111111)
    * 尾数1.M  省略1


## 奇偶校验码

**原理**

奇校验码：整个校验码（有效信息位和校验位）中“1”的个数为奇数

偶校验码：整个校验码（有效信息位和校验位）中“1”的个数为偶数

`在高位补一个 奇偶校验位`

如有偶数个bit发生错误则检测不出来



**硬件实现** 

* 各信息进行异或运算
* **求偶校验位**  将所有信息(bit)异或 得到几就在最高位补几（0/1）
* **进行偶校验**  所有位进行异或，若结果为1说明出错



## 算数逻辑单元(ALU)

### 逻辑运算

<div style="display: flex; flex-wrap: wrap; justify-content: center;">
<img src="C:/Users/17363/AppData/Roaming/Typora/typora-user-images/image-20240310160842591.png" style="margin: 10px;" width="500" height="300">
<img src="C:/Users/17363/AppData/Roaming/Typora/typora-user-images/image-20240310161448736.png" style="margin: 10px;" width="500" height="300">
<img src="C:/Users/17363/AppData/Roaming/Typora/typora-user-images/image-20240310162436234.png" style="margin: 10px;" width="500" height="300">
<img src="C:/Users/17363/AppData/Roaming/Typora/typora-user-images/image-20240310162501811.png" style="margin: 10px;" width="500" height="300">
</div>


### 加法器

**一位 全加器**

<img src="C:/Users/17363/AppData/Roaming/Typora/typora-user-images/image-20240310164005459.png" style="margin: 10px;" width="500" height="300">

**串行加法器**

<img src="C:/Users/17363/AppData/Roaming/Typora/typora-user-images/image-20240310164435590.png" style="margin: 10px;" width="500" height="300">

**并行加法器**

==串行==

<img src="C:/Users/17363/AppData/Roaming/Typora/typora-user-images/image-20240310164547643.png" style="margin: 10px;" width="500" height="300">

==并行==
<img src="C:/Users/17363/AppData/Roaming/Typora/typora-user-images/image-20240310165438316.png" style="margin: 10px;" width="500" height="300">

==加法器原理==

整数和无符号位整数都可以使用  但是**判断溢出的方式不同**

<div>
<img src="C:/Users/17363/AppData/Roaming/Typora/typora-user-images/image-20240310165851557.png" style="margin: 10px;" width="500" height="300">
<img src="C:/Users/17363/AppData/Roaming/Typora/typora-user-images/image-20240310170442689.png" style="margin: 10px;" width="500" height="300">
</div>

### 加减运算

**`原码的加减运算  `** -> 符号位怎么办 ？？ 

<img src="C:/Users/17363/AppData/Roaming/Typora/typora-user-images/image-20240310171600925.png"  style="zoom: 33%; margin: 10px;">

**`补码的加减运算`** -> **符号位参与运算**

### 溢出判断

* **上溢** 正数 + 正数 = 负数
* **下溢** 负数 + 负数 = 正数

1.**一位符号位**  

<img src="C:/Users/17363/AppData/Roaming/Typora/typora-user-images/image-20240310174023739.png"  style="zoom: 33%; margin: 10px;">

2.**一位符号位，根据数据位进位情况**

上溢 **最高数值**位进位（往符号位进1）  正 + 正

下溢 **符号位**进位（往符号位前一位进1）  负 + 负

<img src="C:/Users/17363/AppData/Roaming/Typora/typora-user-images/image-20240311000938900.png"  style="zoom: 33%; margin: 10px;">



3.**双符号位（变形补码）**

原理同2

`模四补码`

<img src="C:/Users/17363/AppData/Roaming/Typora/typora-user-images/image-20240311183653554.png"  style="zoom: 33%; margin: 10px;">

### 符号扩展

<img src="C:/Users/17363/AppData/Roaming/Typora/typora-user-images/image-20240311184310807.png"  style="zoom: 33%; margin: 10px;">



### 符号位

* ==OF== 
  * `有符号数`的加减运算是否发送溢出  OF = 1， 说明发生了溢出
  * 硬件的计算方法： `最高位产生的进位 异或 次高位产生的进位`
  * OF对无符号数的加减法无意义
* ==SF==
  * 有符号数加减运算结果的正负性， SF = 0 表示运算的结果为正数 ，SF  = 1 表示运算的结果为负数
  * 硬件的计算方法：SF = 最高位的本位和
  * SF对无符号数的加减法无意义
* ==ZF==
  * 表示运算结果是否为0 ZF = 1 表示运算结果为0
  * 硬件的计算方法：n bit圈为0时
* ==CF==
  * `无符号数`的加减法是否发生了进位或借位， 当CF = 1时， 说明无符号位的加减法运算发生了溢出
  * 硬件的计算方法：CF = `最高位产生的进位 异或 sub(sub = 1 表示减法   sub = 0 表示加法)`
  * CF对有符号数的加减法无意义

### 移位运算

> 移位: 通过改变各个数码位和小数点的相对位置，从而改变各数码位的位权。可用位移运算实现乘法、除法
>
> **右移**：高位补0， 低位舍去。被舍弃的位=0， 相当于`÷2`  会**丢失精度**
>
> **左移**：低位补0， 高位舍去。被舍弃的位=0， 相当于`×2`  会出现**严重误差**

**原码** 符号为保持不变，仅对数值位进行移位

**反码**

* 正数 和原码一样
* 负数 左移右移都`补1`

**补码**

* 正数同上
* 负数   `左移 低位补0   右移 高位补1`



**逻辑移位**

右移 高位补0 低位舍去

左移 低位补0 高位舍去

看作是对**“无符号数”**的算数移位

逻辑移位的应用 - > R G B



**循环移位**

<img src="C:/Users/17363/AppData/Roaming/Typora/typora-user-images/image-20240311192601653.png"  style="zoom: 33%; margin: 10px;">



## 乘法除法运算

### **原码一位乘法**

* 符号单独处理：符号为 = 符号位 的 异或
* 数值位**取绝对值**进行乘法运算

n轮的加法、移位

**逻辑右移**

符号位不参与运算



<img src="C:/Users/17363/AppData/Roaming/Typora/typora-user-images/image-20240311193613860.png"  style="zoom: 33%; margin: 10px;">

<div style="display: flex; justify-content: space-between;">
<img src="C:/Users/17363/AppData/Roaming/Typora/typora-user-images/image-20240311193851629.png"  style="zoom: 33%; margin: 10px;">
<img src="C:/Users/17363/AppData/Roaming/Typora/typora-user-images/image-20240311194205792.png"  style=" margin: 10px;" width = 500 height = 300>
</div>



### **补码**的一位乘法

n轮加法、移位，最后在**多来一次加法**

补码的**算数右移**

符号位参与运算

<div style="display: flex; justify-content: space-between;">
<img src="C:/Users/17363/AppData/Roaming/Typora/typora-user-images/image-20240311194921627.png"  style="zoom: 30%; margin: 10px;">
<img src="C:/Users/17363/AppData/Roaming/Typora/typora-user-images/image-20240311195538363.png"  style="zoom: 30%; margin: 10px;">
</div>
<img src="C:/Users/17363/AppData/Roaming/Typora/typora-user-images/image-20240311195747992.png"  style="zoom: 30%; margin: 10px;">





### 原码除法

**恢复余数法**

> 规律：忽略小数点，每确定一位商，进行一次减法，得到4位余数，在余数末尾补0， 在确定下一位商。确定5位商即可停止（机器字长为5位）
>
> `被除数小于除数 ` 定点小数无法表示整数

逻辑**左移**

<div style="display: flex; justify-content: space-between;">
<img src="C:/Users/17363/AppData/Roaming/Typora/typora-user-images/image-20240311202657590.png"  style="zoom: 30%; margin: 10px;">
<img src="C:/Users/17363/AppData/Roaming/Typora/typora-user-images/image-20240311202852645.png"  style="zoom: 30%; margin: 10px;">
</div>
<img src="C:/Users/17363/AppData/Roaming/Typora/typora-user-images/image-20240311204514464.png"  style="zoom: 30%; margin: 10px;">



### 加减交替法

**新余数为负数   -  > 商0， 余数左移并 + 除数的绝对值**

**新余数为正数   -  > 商1， 余数左移并 -  除数的绝对值**

加/减 n +1 次  每次加减确定一位商

左移n次 （最后一次加减完不移位）

最终可能还要在多加一次  （**最后余数为负数**）

<img src="C:/Users/17363/AppData/Roaming/Typora/typora-user-images/image-20240311205727825.png"  style="zoom: 30%; margin: 10px;">

<div style="display: flex; justify-content: space-between;">
<img src="C:/Users/17363/AppData/Roaming/Typora/typora-user-images/image-20240311205617087.png"  style="zoom: 30%; margin: 10px;">
<img src="C:/Users/17363/AppData/Roaming/Typora/typora-user-images/image-20240311205754235.png"  style="zoom: 30%; margin: 10px;">
</div>



### 补码除法

<img src="C:/Users/17363/AppData/Roaming/Typora/typora-user-images/image-20240311210743451.png"  style="zoom: 30%; margin: 10px;">



## C语言强制类型转换

C语言中定点整数是用“补码”存储的

* 无符号数与有符号数不改变数据内容， 改变数据解释方式

* 长整数变短整数 高位截断 保留低位
* 短整数变长整数 高位填0
* 32位
  * int 表示整数 -2^32^ ~ 2^32^ - 1， 有效数字32位
  * float 表示整数以及小数， 范围 +- 2^126^ ~ 2^127^ × (2 - 2^-23^) 有效数字 23 + 1 = 24
  * int  -> float 可能损失精度
  * float - > int 可能溢出以及损失精度


<img src="C:/Users/17363/AppData/Roaming/Typora/typora-user-images/image-20240318115810482.png"  style="zoom: 30%; margin: 10px;">


## 浮点数表示 

> 定点数可表示的数字范围有限，但我们不能无限制的增加数据的长度

科学计数法

`阶符  阶码  数符  尾数`

### **小数点的位置浮动**

尾数给出一个小数，阶码指明了小数点要向前/向后移动几位

* ==阶码(E)==
  * 常用补码或移码表示定点定点整数
  * 反应浮点数的表示范围及小数点的实际位置
* ==尾数(M)==
  * 常用原码或者补码表示的定点小数
  * 数值部分的位数n反应浮点数的精度

浮点数的真值 N = r^E^ x M 

 `r `为阶码的底，通常为  2

### 浮点数尾数的规格化



<img src="C:/Users/17363/AppData/Roaming/Typora/typora-user-images/image-20240313224515308.png" alt="image-20240313224515308" style="zoom: 25%;" />

==规格化浮点数== 规定尾数的**最高数值必须是一个有效值**

左规：当浮点数运算的结果为**非规格化时要进行规格化处理**，将尾数算数左移一位，阶码减1

右规：当浮点数运算的结果位数出现**溢出（双符号位为01或10）**时 将尾数算数右移一位，阶码加1   

**双符号位 发生溢出时   更高的符号位为正确的**



**`浮点数规格化的特点`**

* 原码
  * 用原码表示的尾数  最高位必须是1   `0.1......  `（正数）
  * 表示范围 1/2  ~ 1 - 2^-n^     0.1000 ~ 0.1111
  * 负数依旧  只是符号位为1       `1.1......`
  * 表示范围 -(1 - 2^-n^) ~ -1/2   1.1111 ~1.1000
* 补码
  * 用原码表示的尾数  最高位必须是1   `0.1... ` （正数）
  * 表示范围 1/2  ~ 1 - 2^-n^     0.1000 ~ 0.1111
  * 负数 最高数值位为0   `1.0...`
  * 表示范围 -1 ~ -(1/2 + 2^-n^)  1.0000 ~ 1.0111
  * `负数 补码算数左移， 低位补0； 补码算数右移， 高位补1`

**`溢出都右规 01（左面补0） 10（左面补1）`**

**`尾数右移几位  阶码要加几（左移相当于乘2）`**

### 浮点数标准~IEEE745~

> 移码：补码的基础上符号位取反， **移码只能用来表示整数**
>
> 移码的定义     移码 = 真值 + 偏置值
>
> 此处8位移码的偏置值 = 128D = 1000 0000B 即2^n-1^
>
> `偏置值也可以取其他值` 127D  01111111

<img src="C:/Users/17363/AppData/Roaming/Typora/typora-user-images/image-20240314003151199.png" alt="image-20240314003151199" style="zoom:33%;" />


<div style="display: flex; justify-content: space-between;">
<img src="C:/Users/17363/AppData/Roaming/Typora/typora-user-images/image-20240314003600987.png"  style="zoom: 33%; margin: 10px;">
<img src="C:/Users/17363/AppData/Roaming/Typora/typora-user-images/image-20240314003712730.png"  style=" margin: 10px;" width = 500 height = 300>
</div>


**数符 阶码 （用移码表示） 尾数（用原码表示）**

**最小绝对值**   阶码 -126 （-128， -127有其他特殊用法）   尾数全为 0     1.0  x 2^-126^

**最大绝对值**   阶码 127  尾数全为1   1.111 x 2^127^



当阶码全为0  尾数M不全为0时，表示非规格化小数 0.M

当阶码全为0  尾数M全为0时，表示真值+-0

当阶码全为1  尾数M全为0时，表示无穷大

当阶码全为1  尾数M不全为0时，表示非数值 NAN

<img src="C:/Users/17363/AppData/Roaming/Typora/typora-user-images/image-20240314004404675.png" alt="image-20240314004404675" style="zoom: 33%;" />

### 浮点数计算

加法、减法运算：多阶段（并行）

1. 对阶操作（精度范围）  **阶数小的向阶数大的对齐** （方便计算机对尾数处理  -> 尾部是定点小数）
2.  尾数相加 
3. 结果规则化  
4. 舍入处理
   1. 0 舍 1 入法  移去的最高数值位为几就加几（可能发送新的溢出）
   2. 恒置 1 法  直接把剩余的末尾变为1
5. 溢出判断 运算后阶码超出范围则溢出
   1. 正上溢 负上溢  抛出异常
   2. 正下溢 负下溢 当做机器0
6. z = x + y = (Mx * 2^Ex-Ey^ + My) * 2^Ey^   Ex < Ey

<img src="C:/Users/17363/AppData/Roaming/Typora/typora-user-images/image-20240314011257742.png" alt="image-20240314011257742" style="zoom:33%;" />



**流水线工作**

t~k~  = (k +(n - 1)) T

* k个过程段
* n个任务
* T 一个过程时间

不用流水线  t~l~ = k * n * T

加速比 C~k~  = t~l~ / t~k~

## 数据点存储和排列

**大小端模式**

最高有效字节 最低有效字节

* **大端方式（便于人类阅读）**  地址从低到高 存 最高有效字节 到 最低有效字节
* **小端方式（方便机器处理）**  地址从低到高 存 最低有效字节 到 最高有效字节

**边界对齐**

> 现在计算机通常按字节编址， 每个字节对应1个地址
>
> 通常也支持按字、按半字、按字节寻址

**空间换时间**





# 储存系统

## 存储器概述

计算机系统中的记忆设备，用来存放程序和数据

* 存储器的分层（层次化结构）

<img src="C:/Users/17363/AppData/Roaming/Typora/typora-user-images/image-20240318121243248.png" alt="image-20240314004404675" style="margin: 10px;" width="500" height="300" />


* 存储器的分类

  * 按层次分类  cache 主存 / 辅存

  * 按存储介质  半导体 / 磁性材料 / 光介质

  * 按存取方式  随机存取（RAM） / 顺序存取（SAM） / 直接存取（DAM） [串行访问存储器] / 相联存储器（CAM）[直接找数据内容]

  * 按信息的可更改性  读写 / 只读（ROM） 

  * 按信息的可保存性  易失性存储 / 非易失性存储   破坏性读出（DRAM） / 非破坏性读出（SRAM）

* 存储器的指标      容量大 速度快 成本低

  * 存储容量  存储字数（MAR反应） × 字长（MDR反应）
  * 单位成本  每位价格（bit） = 总成本/总容量
  * 存储速度  数据传输率 = 数据的宽度/存储周期
  * 存储周期   =  存取时间 + 恢复时间 （DRAM恢复时间较长 破坏性读取）
  * 存储宽度
* <img src="C:/Users/17363/AppData/Roaming/Typora/typora-user-images/image-20240318123316730.png" alt="image-20240314004404675" style="margin: 10px;" width="500" height="300" />





## 主存储器的基本组成

### 半导体元件以及原理

<img src="C:/Users/17363/AppData/Roaming/Typora/typora-user-images/image-20240318124157675.png" alt="image-20240314004404675" style="margin: 10px;" width="500" height="300" />

### 存储器芯片的基本原理

<img src="C:/Users/17363/AppData/Roaming/Typora/typora-user-images/image-20240318124955455.png" style=" margin: 10px;" width = 500 height = 300>

<div style="display: flex; justify-content: space-between;">
<img src="C:/Users/17363/AppData/Roaming/Typora/typora-user-images/image-20240318125244416.png"  style=" margin: 10px;" width = 500 height = 300>
<img src="C:/Users/17363/AppData/Roaming/Typora/typora-user-images/image-20240318125459177.png"  style=" margin: 10px;" width = 500 height = 300>
</div>


### 寻址
<img src="C:/Users/17363/AppData/Roaming/Typora/typora-user-images/image-20240318125814633.png"  style=" margin: 10px;" width = 500 height = 300>



## RAM

### SRAM 

（static）

* 静态RAM  多用于Cache
* 存储元 双稳态**触发器**  非破坏性读出 （读写更快  ）
* **不需要刷新**
* **同时送行列地址**

<img src="C:/Users/17363/AppData/Roaming/Typora/typora-user-images/image-20240617201556487.png" alt="image-20240617201556487" style="zoom: 50%;" />

### DRAM

* 动态RAM 用于主存 可读 可写 
* 存储元  栅极**电容**  **破坏性读出**
* 需要**刷新** 电容里面的电荷只能维持两毫米
  * 刷新周期 2ms
  * 每次刷新多少存储单元 以行为单位 每次刷新一行
  * 存储单元变成二维 行列地址 减少选通线的数量
  * 读取一行的信息后重新写入 占用一个读/写周期
  * 如何刷新
    * 分散刷新 - > 每次读写都刷新一行  存储中心变大
    * 集中刷新 - > 集中安排时间全部刷新
    * 异步刷新 - > 产生128次刷新需求
* **分两次 送行列地址**

<img src="C:/Users/17363/AppData/Roaming/Typora/typora-user-images/image-20240617203040254.png" alt="image-20240617203040254" style="zoom:50%;" />

<img src="C:/Users/17363/AppData/Roaming/Typora/typora-user-images/image-20240318222644167.png"  style=" margin: 10px;" width = 500 height = 300>

## ROM

> 只读存储器，速度比RAM还快，断电不遗失信息
>
> 控制存储器（CM）用ROM构成

特点：只能读，不能写

分类

* **掩膜ROM**
  * 存储内容固定的ROM
  * 用集体管的导通/截止来表示1/0
  * 一旦烧成，**不能改写** （成本高，适合批量定制）
* **可编程ROM**
  * PROM：用户可用专门的写入器写入信息 写一次后就不能更改
  * EPROM：光擦除可编程只读存储器（紫外线擦除需要到厂家）
    * UVEPROM： 紫外线

  * EEPROM：点擦除可编程只读存储器（高电压 主板就可控制）

* flash memory 闪速存储器 (u盘， SD卡） 在 EEPROM基础上发展而来 
  * 可进行多次快速擦除重写
  * 善存的“写”速度比“读”的速度更快 （需要先擦除在写入）

* SSD 固态硬盘
  * 多次快速擦除重写
  * 与闪存的核心区别在于控制单元不同


## 双端口存储器

**双端口存储器**

内存与CPU**速度不匹配** - >  优化多核cpu访问一根内存条的宿舍

* 同一个存储器具有**两组相互独立的读写控制线** （两个独立的访问端口）

* 分别具有**地址线 数据线和控制线**  （两个cpu从不同的线访问  双核）

* **BUSY** 访问线  判断左右**两路是否有冲突** （两个端口访问的==地址相同==）    判断逻辑给优先级（低电平有效）

**多模块交叉存储器**

解决恢复时间太慢  cpu速度仍快于主存

**顺序地址**

特点

* 某个模块进行存储时，其他模块不工作
* 某一模块出现故障时，其他模块**正常工作**
* 增添模块**扩充容量**比较方便
* 各模块串行工作，难以采用流水线提高带宽

**交叉地址**(多体并行存储器)   另外一个不同的 单体多字存储器

特点

* 同一个模块内的地址都是**不连续的**
* 对连续的成组访问可实现流水线**并进行存取**，提高存储器带宽

<div style="display: flex; justify-content: space-between;">
<img src="C:/Users/17363/AppData/Roaming/Typora/typora-user-images/image-20240318230623144.png"  style=" margin: 10px;" width = 500 height = 300>
<img src="C:/Users/17363/AppData/Roaming/Typora/typora-user-images/image-20240318231039793.png"  style=" margin: 10px;" width = 500 height = 300>
</div>


时间：(T+d) + （n - 1）d = T + (n -  1)d

非流水：(T + d) * n = T * n

## 存储器与CPU的连接

<img src="C:/Users/17363/AppData/Roaming/Typora/typora-user-images/image-20240319001421596.png"  style=" margin: 10px;" width = 500 height = 300>

***

**位扩展**  ->  增加主存的存储字长  -> 发挥数据总线的数据传输能力


<div style="display: flex; justify-content: space-between;">
<img src="C:/Users/17363/AppData/Roaming/Typora/typora-user-images/image-20240319092859306.png"  style=" margin: 10px;" width = 500 height = 300>
<img src="C:/Users/17363/AppData/Roaming/Typora/typora-user-images/image-20240319093010248.png"  style=" margin: 10px;" width = 500 height = 300>
</div>
***

**字扩展** - > 增加主存的存储字数  - > 更好的利用cpu的寻址能力

<img src="C:/Users/17363/AppData/Roaming/Typora/typora-user-images/image-20240319094647106.png"  style=" margin: 10px;" width = 500 height = 300>

<div style="display: flex; justify-content: space-between;">
<img src="C:/Users/17363/AppData/Roaming/Typora/typora-user-images/image-20240319095347778.png"  style=" margin: 10px;" width = 500 height = 300>
<img src="C:/Users/17363/AppData/Roaming/Typora/typora-user-images/image-20240319095723272.png"  style=" margin: 10px;" width = 500 height = 300>
</div>
***

**字位同时扩展** -> 主存容量扩展

<div style="display: flex; justify-content: space-between;">
<img src="C:/Users/17363/AppData/Roaming/Typora/typora-user-images/image-20240319100243336.png"  style=" margin: 10px;" width = 500 height = 300>
<img src="C:/Users/17363/AppData/Roaming/Typora/typora-user-images/image-20240319100418700.png"  style=" margin: 10px;" width = 500 height = 300>
</div>
***

**译码器**


<div style="display: flex; justify-content: space-between;">
<img src="C:/Users/17363/AppData/Roaming/Typora/typora-user-images/image-20240319100634549.png"  style=" margin: 10px;" width = 500 height = 300>
<img src="C:/Users/17363/AppData/Roaming/Typora/typora-user-images/image-20240319101229424.png"  style=" margin: 10px;" width = 500 height = 300>
</div>


## 外部存储器

**磁表面存储器**

* 优点
  * ①存储容量大，位价格低;    ②记录介质可以重复使用;
    ③记录信息可以长期保存而不丢失，甚至可以脱机存档
    ④非破坏性读出，读出时不需要再生。
* 缺点
  * ①存取速度慢;    ②机械结构复杂;
    ③对工作环境要求较高。

<img src="C:/Users/17363/AppData/Roaming/Typora/typora-user-images/image-20240319102648400.png"  style=" margin: 10px;" width = 500 height = 300>


<div style="display: flex; justify-content: space-between;">
<img src="C:/Users/17363/AppData/Roaming/Typora/typora-user-images/image-20240319103516123.png"  style=" margin: 10px;" width = 500 height = 300>
<img src="C:/Users/17363/AppData/Roaming/Typora/typora-user-images/image-20240319103413664.png"  style=" margin: 10px;" width = 500 height = 300>
</div>
<img src="C:/Users/17363/AppData/Roaming/Typora/typora-user-images/image-20240319104031868.png"  style=" margin: 10px;" width = 500 height = 300>

**磁盘阵列** RAID


<div style="display: flex; justify-content: space-between;">
<img src="C:/Users/17363/AppData/Roaming/Typora/typora-user-images/image-20240319104515823.png"  style=" margin: 10px;" width = 500 height = 300>
<img src="C:/Users/17363/AppData/Roaming/Typora/typora-user-images/image-20240319104627007.png"  style=" margin: 10px;" width = 500 height = 300>
</div>
***

**固态硬盘** SSD

<img src="C:/Users/17363/AppData/Roaming/Typora/typora-user-images/image-20240319105453898.png"  style=" margin: 10px;" width = 500 height = 300>


## cache

**特点**

cache高速缓冲存储器  -> 内存与CPU速度不匹配

* 可高速读取的小容量的存储器，片内cache已经接近CPU的处理速度
* CPU可以直接访问cache
* 可构造2级以上的cache系统
* cache系统实现cache和主存、cache和cache之间的信息交换，对用户是透明的

**基本原理**

* 主存和cache按照约定长度划分为==若干块==
* **cache**实际上是**主存的当前最活跃部分**，即主存的一个子集
* **LRU逻辑管理** 当cache已满、且有新的数据块需要载入时，将最近**最少使用的数据块替换**出去

> 片外cache一般由**主存/cache控制器**提供控制逻辑，负责片外cache与主存、片外cache与片内cache、片外cache与CPU之间的数据交换及控制。片内cache**由CPU提供**控制逻辑，负责片内cache与CPU、片内cache与片外cache、片内cache与主存之间的数据交换及控制。
>
>    CPU～cache：CPU以**机器字**为单位访问cache；
>
>    CPU～内存：CPU以**机器字**为单位访问内存；
>
>    cache～内存：以**定长数据块**为单位数据交换；
>
>    cache～cache：以**定长数据块**为单位数据交换。

**命中率的影响因素**

* 程序行为，**顺序程序**比分支程序命中率高；
* cache的**容量**；
* 组织方式；
* 数据块大小；  越小越快 但是查询时间会增加


<div style="display: flex; justify-content: space-between;">
<img src="C:/Users/17363/AppData/Roaming/Typora/typora-user-images/image-20240320200731724.png"  style=" margin: 10px;" width = 500 height = 300>
<img src="C:/Users/17363/AppData/Roaming/Typora/typora-user-images/image-20240320200854528.png"  style=" margin: 10px;" width = 500 height = 300>
</div>


***



**主存与cache的地址映射**

* 为了把主存块放到cache中合适的位置，必须应用某种方法把主存地址定位到cache中，称为**地址映射**。

* 地址映射由**硬件控制逻辑**实现

**地址映射方式**

* **全相联**映射方式  
  * 内存的每一块可以映射到cache中的**任意块**（行），存在替换策略问题
  * 灵活；
  * 比较器 耗时
  
* **直接**映射方式
  * 内存中每组的块和cache中的块一一对应，没有替换策略问题 

* **组相联**映射方式
  * 内存中每组的第i块可映射到cache的第i组中的任意一块（行），存在替换策略的问题

<div style="display: flex; justify-content: space-between;">
<img src="C:/Users/17363/AppData/Roaming/Typora/typora-user-images/image-20240320202813966.png"  style=" margin: 10px;" width = 500 height = 300>
<img src="C:/Users/17363/AppData/Roaming/Typora/typora-user-images/image-20240320203251083.png"  style=" margin: 10px;" width = 500 height = 300>
</div>

<div style="display: flex; justify-content: space-between;">
<img src="C:/Users/17363/AppData/Roaming/Typora/typora-user-images/image-20240320203647683.png"  style=" margin: 10px;" width = 500 height = 300>
<img src="C:/Users/17363/AppData/Roaming/Typora/typora-user-images/image-20240320204223088.png"  style=" margin: 10px;" width = 500 height = 300>
</div>
**替换策略**

* **随机**算法 ->  若cache已满，则随机选择一块替换

  * 随机算法---实现简单，但完全没考少局部性原理，命中率低，实际效果很不稳定

* **先进先出**算法  -> 若Cache已满，则替换**最先**被调入Cache的块

  * FIFO---实现简单，依然没考虑局部性原理，最先被调入Cache的块也有可能是被频繁访问的

* **最不经常使用**算法 LFU

  * 为每一个cache块设置一个“计数器”，用于记录每个Cache块`被访问过几次`。当cache满后替换“计数器”最小的
  * LFU算法――曾经被经常访问的主存块在未来不一定会用到（如:微信视频聊天相关的块)，并没有很好地遵循局部性原理，因此实际运行效果不如LRU

* **近期最少使用**算法 LRU 

  * 为每一个Cache块设置一个“**计数器**”，用于记录每个cache块已经有`多久`没被访问了。当cache满后替换“计数器”最大的

  * Cache块的总数=2^n^，则计数器只需n位。且Cache装满后所有计数器的值一定不重复

  * LRU -> 基于“局部性原理”，近期被访问过的主存块，在不久的将来也很有可能被再次访问，因此淘汰最久没被访问过的块是合理的。LRU算法的实际运行效果优秀，cache命中率高。

    

<img src="C:/Users/17363/AppData/Roaming/Typora/typora-user-images/image-20240320213450139.png"  style=" margin: 10px;" width = 500 height = 300>

  **写操作策略**

写命中

* 写回法   （有效位 脏位）
  * 当CPU对Cache写命中时，**只修改Cache的内容**，而不立即写入主存，只有当此块被**换出时**才写回主存
  * 减少了访存次数，但**存在数据不一致的隐患**。

* 全写法
  * 当CPU对Cache写命中时，必须**把数据同时写入Cache和主存**，一般使用写缓冲
  * **访存次数增加**，速度变慢，但更能保证数据一致性
  * 使用写缓冲，CPU写的速度很快，若写操作不频繁，则效果很好。若写操作很频繁，可能会因为写缓冲饱和而发生阻塞

* 写一次法
  * **写一次法是指第一次写**cache命中时要同时写入主存，以后的写操作只写cache，替换时再写主存。
  * **第一次写**cache命中时同时写入主存，目的是通知多cache系统中的其它cache和主存，这个数据块发生了写操作，应**实施数据一致性**策略


写不命中

* 写分配法
  * 当CPU对Cache写不命中时，把主存中的块调入Cache，在Cache中修改。通常搭配**写回法**使用。写分配法(写分配)
* 非写分配法
  * 当CPU对Cache写不命中时只写入主存，不调入Cache。搭配**全写法**使用



***



## 存储器

* 实现组存和外存之间的信息部分调入调出
* 侧重解决主存容量不足， 提供一个比实际主存空间大的逻辑空间
* 物理地址空间 2^n^   地址总线为n跟         虚拟地址空间远远大于物理地址空间
* 段
  * 段的优点：段的分界与程序的自然分界相对应；段的逻辑独立性使它易于编译、管理、修改和保护；以段为单位在主存-外存之间调入调出不会改变程序的结构性质，保证程序的完整性、一致性。
  * 段的缺点：由于段的长度各不相同，给主存空间的预留、分配带来麻烦。
  * 基于段表的管理和地址变换
* 页

***

**页式存储器**  拆分成大小相等的页面

页式存储系统:一个程序(进程)在逻辑上被分为若干个大小相等的“页面”，`“页面”大小与“块”的大小相同`。每个页面可以离散地放入不同的主存块中。


<img src="C:/Users/17363/AppData/Roaming/Typora/typora-user-images/image-20240320223712807.png"  style=" margin: 10px;" width = 500 height = 300>

<div style="display: flex; justify-content: space-between;">
<img src="C:/Users/17363/AppData/Roaming/Typora/typora-user-images/image-20240320224126683.png"  style=" margin: 10px;" width = 500 height = 300>
<img src="C:/Users/17363/AppData/Roaming/Typora/typora-user-images/image-20240320224635294.png"  style=" margin: 10px;" width = 500 height = 300>
</div>

<img src="C:/Users/17363/AppData/Roaming/Typora/typora-user-images/image-20240320225015254.png"  style=" margin: 10px;" width = 500 height = 300>

***

**虚拟存储器**

**虚拟存储器的技术目的是侧重解决主存容量不足，属于主存和外存之间的问题。**

**以透明的方式为用户提供一个比实际主存空间大得多的逻辑空间，使之为更大或更多的程序所使用。用户在编写程序时不需要考虑所编程序在主存中是否放得下或放在什么位置等具体细节问题**



<div style="display: flex; justify-content: space-between;">
<img src="C:/Users/17363/AppData/Roaming/Typora/typora-user-images/image-20240320230447318.png"  style=" margin: 10px;" width = 500 height = 300>
<img src="C:/Users/17363/AppData/Roaming/Typora/typora-user-images/image-20240320230543487.png"  style=" margin: 10px;" width = 500 height = 300>
</div>


***



**段式存储器** 按照功能模块进行拆分

<img src="C:/Users/17363/AppData/Roaming/Typora/typora-user-images/image-20240320231113329.png"  style=" margin: 10px;" width = 500 height = 300>

***

段页式存储器

<img src="C:/Users/17363/AppData/Roaming/Typora/typora-user-images/image-20240320231248151.png"  style=" margin: 10px;" width = 500 height = 300>





# 指令系统

## 基本概念

> 指令是**软件和硬件**分界面的一个主要标志
>
> 是指示计算机执行某种操作的命令，是计算机运行的**最小功能单位**。
>
> 一台计算机的**所有指令的集合**构成该机的指令系统，也称为==指令集==。
>
> Eg： x86架构 （PC端）  ARM架构 （手机）

* 指令

  * 微指令 微程序级的命令，属于硬件

  * 宏指令 若干条机器指令组合成的软件指令，属于软件 （可理解为**高级程序语言代码**）



指令系统要求

* **完备性**  最基本和最常用的指令有定义，并且有硬件实现电路
* **有效性**  指令编写的程序能高效运行
* **规整性**
  * 对称性  同等对待
  * 均齐性   一种指令支持各种数据类型
  * 一致性  指令长度和数据长度有一定关系
* **兼容性**  向上兼容  -> 低档机的软件可以在高档机运行
* **扩展性**  预留一定的编码空间



指令助记符 便于阅读和书写

## 指令格式

**操作码字段OP + 地址码字段A**

* 操作码：指明指令的**操作性质**以及功能

* 地址码：给出**操作数的地址**，可以有多个

  * 零地址指令  
    * 1.不需要操作数，如空操作、停机、关中断等指令
    * 2.堆栈计算机，两个操作数隐含存放在栈顶和次栈顶，计算结果压回栈顶2.堆栈计算机，两个操作数隐含存放在栈顶和次栈顶，计算结果压回栈顶一地址指令

  * 一地址指令
    * 1.只需要单操作数，如加1、减1、取反、求补等
    * 2.需要两个操作数，但其中一个操作数隐含在某个寄存器（如隐含在ACC)


  * 二地址指令  目的操作数 + 源操作数   读取一二位地址 然后**写入第一位**
  * 三地址指令  读取一二位地址 然后**写入第三位**
  * 四地址指令  第四位存下一次访问的地址，使pc**不按照顺序执行**



**双地址指令格式**

操作码  目标操作数  源操作数

* 存储器-存储器SS型指令   执行时间长     内存-内存
* 寄存器-寄存器RR型指令  执行时间短     寄存器-寄存器（CPU内部）
* 寄存器-存储器RS型指令  执行时间较短



–机器字：计算机能直接处理的最长的二进制数据；

–机器字长：计算机能直接处理的最长的二进制数据的位数；

–指令字：表示一条指令的机器字；

–指令字长度：指令中包含的二进制代码的位数，包括操作码和操作数字段；

## 指令分类

**指令长度分类**  - > 指令字长  - > 指令长度是机器字长的多少倍

* 半字长指令
* 单字长指令
* 双字长指令
* 指令字长会影响取指令所需时间。如:机器字长=存储字长=16bit，则取一条双字长指令需要**两次访存**
* **定长**指令字结构:指令系统中所有指令的长度都相等
* **变长**指令字结构:指令系统中各种指令的长度不等

**操作码长度**

* **定长**操作码:指令系统中所有指令的操作码长度都相同  **n位→2^n^条指令**
  * 控制器的译码电路设计简单，但灵活性较低
* **可变长**操作码:指令系统中各指令的操作码长度可变
  * 控制器的译码电路设计复杂，但灵活性较高
* **扩展操作码**指令格式  - > 定长指令字结构+可变长操作码
  * 不同地址数的指令使用不同长度的操作码
  * 优:在指令字长有限的前提下仍保持比较丰富的指令种类;
  * 缺:增加了指令译码和分析的难度，使控制器的设计复杂化。

**操作类型**

* 数据传送
* 运算类
  * 算数逻辑操作
  * 移位操作
* 转移操作 （程序控制类 - > 改变程序执行的顺序）
* 输入输出操作



## 扩展操作码

在设计扩展操作码指令格式时，必须注意以下两点:·在设计扩展操作码指令格式时，必须注意以下两点：

1. **不允许短码是长码的前缀**，即短操作码不能与长操作码的前面部分的代码相同
2. 各指令的操作码一定不能重复

>通常情况下，对使用频率较高的指令，分配较短的操作码；对使用频率较低的指令，分配较长的操作码，从而尽可能减少指令译码和分析的时间

<img src="C:/Users/17363/AppData/Roaming/Typora/typora-user-images/image-20240327201203154.png"  style=" margin: 10px;" width = 500 height = 300>





## 寻址方式


### 指令寻址

下一条 欲执行指令 的 地址 （始终由程序计数器PC给出）

**顺序寻址**

<div style="display: flex; justify-content: space-between;">
<img src="C:/Users/17363/AppData/Roaming/Typora/typora-user-images/image-20240327203002393.png"  style=" margin: 10px;" width = 500 height = 300>
<img src="C:/Users/17363/AppData/Roaming/Typora/typora-user-images/image-20240327204938067.png"  style=" margin: 10px;" width = 500 height = 300>
</div>
<img src="C:/Users/17363/AppData/Roaming/Typora/typora-user-images/image-20240327205644212.png"  style=" margin: 10px;" width = 500 height = 300>

**跳跃寻址**

<img src="C:/Users/17363/AppData/Roaming/Typora/typora-user-images/image-20240327210654296.png"  style=" margin: 10px;" width = 500 height = 300>



### 操作数寻址 

数据寻址  - > 确定 本条指令 的 地址码指明的真实地址

`操作码OP  +  寻址特征  +  形式地址A`

默认指令字长 = 机器字长 = 寻址字长  `EA表示存数据的地址`

BR--- base address register

EA--- effective address

* **隐含寻址**   不是明显地给出操作数的地址，而是在指令中隐含着操作数的地址
  * 操作码 + 寻址特征（隐含寻址） + 真实的地址    （**会有另一个操作数在ACC中的数据加入**）
  * 优点：有利于缩短指令字长
  * 缺点：需增加存储操作数或**隐含地址的硬件**。

* **立即寻址**  （直接寻址）  **形式地址就是操作数**
  * 立即寻址:形式地址A就是**操作数本身**，又称为立即数，一般采用**补码**形式。`#`表示立即寻址特征（立即数）。
  * 取指 和 执行指令 各 访存 0次 
  * 优点：指令执行阶段不访问主存，指令执行时间最短
  * 缺点：A的位数限制了立即数的范围。 如A的位数为n，且立即数采用补码时，可表示的数据范围为 - 2^n-1^ ~ 2^n-1^ - 1

* **直接寻址**
  * 操作码 + 寻址特征（直接寻址） + 真实的地址    `EA=A`
  * 取指 和 执行指令 各 访存 一次  共访存两次 
  * 优点： 简单，执行指令阶段仅访问一次主存，不需要专门计算
  * 缺点：寻址访问 不是很大， 操作数的地址不易修改 灵活性较差

* **间接寻址**
  * 操作码 +寻址特征（间接寻址） + 间接地址（操作数地址的地址）  - > 一次间接寻址  二次间接寻址 等等
  * 指令的地址字段给出的形式地址不是操作数的真正地址，而是操作数有效地址所在的**存储单元的地址**，也就是**操作数地址的地址**,，`EA=(A)`。
  * 取指 访存一次  **执行指令访存2次（一次间接寻址）**
  * 优点
    * 可以**扩大寻址范围**（有效地址EA的位数大于形式地址A的位数）
    * 便于编制程序（用间接寻址可以方便的完成子程序的返回）

  * 缺点：指令在执行阶段要**多次访存**(一次间址需两次访存，多次寻址需根据存储字的最高位确定几次访存)。

* **寄存器寻址**
  * 操作码 +寻址特征（寄存器寻址） + 寄存器编号  `EA = Ri`
  * 取指 **访存一次** 执行指令 访存0次
  * 优点
    * 在执行阶段不访问主存，只**访问寄存器**
    * 指令字短（寄存器数目少 贵）且执行速度快，支持向量/矩阵运算

  * 缺点：寄存器价格昂贵，计算机中寄存器的个数有限

* **寄存器间接寻址**
  * 操作码 + 寻址特征（寄存器间接寻址） + 寄存器编号（指向操作数的地址） `EA=（Ri）`
  * 取指 和 执行指令 各 访存 一次
  * 特点：与一般间接寻址相比速度**更快**，但指令的**执行阶段需要访问主存**(因为操作数在主存中)。

* ==偏移寻址==  注意：取出当前指令后，PC会指向下一条指令，相对寻址是相对于**下一条指令的偏移**
  
  * 基址寻址：以程序的起始存放地址作为“起点” `EA = (BR) + A`
		
		* 基址寄存器（BR）是**面向操作系统**的，其内容由**操作系统**或**管理程序**确定。在程序执行过程中，`基址寄存器的内容不变（作为基地址）， 形式地址可变（作为偏移量）`
	
  	* 当采用**通用寄存器**作为基址寄存器时，可由用户决定哪个寄存器作为基址寄存器，但其内容**仍由操作系统**确定。
  
  	* 优点：可**扩大寻址范围**（基址寄存器的位数大于形式地址A的位数)；用户不必考虑自己的程序存于主存的哪一空间区域，故有利于==多道程序设计==，以及可用于编制**浮动程序**(`整个程序在内存里边的浮动)`。
  	
  	
  	<div style="display: flex; justify-content: space-between;">
  	<img src="C:/Users/17363/AppData/Roaming/Typora/typora-user-images/image-20240331131607380.png"  style=" margin: 10px;" width = 500 height =300>
  	<img src="C:/Users/17363/AppData/Roaming/Typora/typora-user-images/image-20240331132322450.png"  style=" margin: 10px;" width = 500 height = 300>
  	</div>
  	
  * 变址寻址：程序员自己决定从哪里作为“起点” `EA = (IX) + A`
  
    * 变址寄存器（IX）是**面向用户**的，在程序执行过程中，变址寄存器的内容可由`用户改变(作为偏移量），形式地址A不变（作为基地址）`
    * 优点：在数组处理过程中，可设定A为数组的首地址，不断改变变址寄存器IX的内容，便可很容易形成数组中任一数据的地址，特别适合编制==循环程序。==
  
    <div style="display: flex; justify-content: space-between;">
    <img src="C:/Users/17363/AppData/Roaming/Typora/typora-user-images/image-20240331133143477.png"  style=" margin: 10px;" width = 500 height =300>
    <img src="C:/Users/17363/AppData/Roaming/Typora/typora-user-images/image-20240331145445807.png"  style=" margin: 10px;" width = 500 height = 300>
    </div>
  
  * 基址&变址复合寻址
  
    * `EA = （IX）+ (BR) + A`
      <img src="C:/Users/17363/AppData/Roaming/Typora/typora-user-images/image-20240331150103475.png"  style=" margin: 10px;" width = 500 height = 300>
  
  
  
  * 相对寻址：以**程序计数器PC**所指地址作为“起点”`EA = (PC) + A`

    * 优点：操作数的地址不是固定的，它随着PC值的变化而变化，并且与指令地址之间总是相差一个固定值，因此便于**程序浮动**`(一段代码在程序内部的浮动)`。
    * 相对寻址广泛应用于==转移指令==
    
    <div style="display: flex; justify-content: space-between;">
    <img src="C:/Users/17363/AppData/Roaming/Typora/typora-user-images/image-20240331150751041.png"  style=" margin: 10px;" width = 500 height =300>
    <img src="C:/Users/17363/AppData/Roaming/Typora/typora-user-images/image-20240331151924142.png"  style=" margin: 10px;" width = 500 height = 300>
    </div>
  
  
  
  * 硬件如何实现数的“比较”
    <img src="C:/Users/17363/AppData/Roaming/Typora/typora-user-images/image-20240331153822378.png"  style=" margin: 10px;" width = 500 height = 300>
  
  
  
* **段寻址**

  * 指令地址码字段只给偏移地址

* **堆栈寻址**  操作数存放在堆栈中，隐含使用堆栈指针(SP)作为**操作数地址**。
    <img src="C:/Users/17363/AppData/Roaming/Typora/typora-user-images/image-20240331154935651.png"  style=" margin: 10px;" width = 500 height = 300>



<img src="C:/Users/17363/AppData/Roaming/Typora/typora-user-images/image-20240618200333474.png" alt="image-20240618200333474" style="zoom:50%;" />



## X86汇编语言

> 起源：代号为8086的CPU  intelx86架构CPU



**x86指令基础**

<div style="display: flex; justify-content: space-between;">
<img src="C:/Users/17363/AppData/Roaming/Typora/typora-user-images/image-20240331161042802.png"  style=" margin: 10px;" width = 500 height =300>
<img src="C:/Users/17363/AppData/Roaming/Typora/typora-user-images/image-20240331161643491.png"  style=" margin: 10px;" width = 500 height = 300>
</div>

<div style="display: flex; justify-content: space-between;">
<img src="C:/Users/17363/AppData/Roaming/Typora/typora-user-images/image-20240331161703932.png"  style=" margin: 10px;" width = 500 height = 300>
<img src="C:/Users/17363/AppData/Roaming/Typora/typora-user-images/image-20240331161831079.png"  style=" margin: 10px;" width = 500 height = 300>
</div>

<div style="display: flex; justify-content: space-between;">
<img src="C:/Users/17363/AppData/Roaming/Typora/typora-user-images/image-20240331162231824.png"  style=" margin: 10px;" width = 500 height = 300>
<img src="C:/Users/17363/AppData/Roaming/Typora/typora-user-images/image-20240331162353249.png"  style=" margin: 10px;" width = 500 height = 300>
</div>


**常用的x86汇编指令**



典型指令

* 数据传送指令
  * MOV 传送  源和目标都是寄存器（比cache快）
  * STO  存数  CPU向存储器传送字
  * LAD  取数  存储器向CPU传送字
  * EXC  交换  寄存器和存储器
  * CLA  清零
  * SEG  置1
  * PUS 进栈
  * POP 出栈
* 算数运算指令
	<div style="display: flex; justify-content: space-between;">
	<img src="C:/Users/17363/AppData/Roaming/Typora/typora-user-images/image-20240331163232759.png"  style=" margin: 10px;" width = 500 height = 300>
	<img src="C:/Users/17363/AppData/Roaming/Typora/typora-user-images/image-20240331163421870.png"  style=" margin: 10px;" width = 500 height = 300>	
	</div>

* 逻辑运算指令
	<div style="display: flex; justify-content: space-between;">
	<img src="C:/Users/17363/AppData/Roaming/Typora/typora-user-images/image-20240331163629240.png"  style=" margin: 10px;" width = 500 height = 300>
	<img src="C:/Users/17363/AppData/Roaming/Typora/typora-user-images/image-20240331163744200.png"  style=" margin: 10px;" width = 500 height = 300>	
	</div>

* 程序控制指令
* 输入输出指令
* 字符串处理指令
* 特权指令
* 其他指令



## AT&T格式

<div style="display: flex; justify-content: space-between;">
<img src="C:/Users/17363/AppData/Roaming/Typora/typora-user-images/image-20240331165133712.png"  style=" margin: 10px;" width = 500 height = 300>
<img src="C:/Users/17363/AppData/Roaming/Typora/typora-user-images/image-20240331165051082.png"  style=" margin: 10px;" width = 500 height = 300>
</div>


## 机器级表示

**实现选择语言**：

<div style="display: flex; justify-content: space-between;">
<img src="C:/Users/17363/AppData/Roaming/Typora/typora-user-images/image-20240331200220485.png"  style=" margin: 10px;" width = 500 height = 300>
<img src="C:/Users/17363/AppData/Roaming/Typora/typora-user-images/image-20240331200317081.png"  style=" margin: 10px;" width = 500 height = 300>
</div>

<div style="display: flex; justify-content: space-between;">
<img src="C:/Users/17363/AppData/Roaming/Typora/typora-user-images/image-20240331200416119.png"  style=" margin: 10px;" width = 500 height = 300>
<img src="C:/Users/17363/AppData/Roaming/Typora/typora-user-images/image-20240331200529707.png"  style=" margin: 10px;" width = 500 height = 300>
</div>
**实现循环语句**

<div style="display: flex; justify-content: space-between;">
<img src="C:/Users/17363/AppData/Roaming/Typora/typora-user-images/image-20240331201233325.png"  style=" margin: 10px;" width = 500 height = 300>
<img src="C:/Users/17363/AppData/Roaming/Typora/typora-user-images/image-20240331201546554.png"  style=" margin: 10px;" width = 500 height = 300>
</div>


**实现函数调用**

<div style="display: flex; justify-content: space-between;">
<img src="C:/Users/17363/AppData/Roaming/Typora/typora-user-images/image-20240331201841977.png"  style=" margin: 10px;" width = 500 height = 300>
<img src="C:/Users/17363/AppData/Roaming/Typora/typora-user-images/image-20240331202048860.png"  style=" margin: 10px;" width = 500 height = 300>
</div>
<img src="C:/Users/17363/AppData/Roaming/Typora/typora-user-images/image-20240331202249406.png"  style=" margin: 10px;" width = 500 height = 300>



<div style="display: flex; justify-content: space-between;">
<img src="C:/Users/17363/AppData/Roaming/Typora/typora-user-images/image-20240331203154005.png"  style=" margin: 10px;" width = 500 height = 300>
<img src="C:/Users/17363/AppData/Roaming/Typora/typora-user-images/image-20240331203255875.png"  style=" margin: 10px;" width = 500 height = 300>
</div>

<div style="display: flex; justify-content: space-between;">
<img src="C:/Users/17363/AppData/Roaming/Typora/typora-user-images/image-20240331203545886.png"  style=" margin: 10px;" width = 500 height = 300>
<img src="C:/Users/17363/AppData/Roaming/Typora/typora-user-images/image-20240331203720465.png"  style=" margin: 10px;" width = 500 height = 300>
</div>


<div style="display: flex; justify-content: space-between;">
<img src="C:/Users/17363/AppData/Roaming/Typora/typora-user-images/image-20240331204944110.png"  style=" margin: 10px;" width = 500 height = 300>
<img src="C:/Users/17363/AppData/Roaming/Typora/typora-user-images/image-20240331205831115.png"  style=" margin: 10px;" width = 500 height = 300>
</div>

<div style="display: flex; justify-content: space-between;">
<img src="C:/Users/17363/AppData/Roaming/Typora/typora-user-images/image-20240331210532003.png"  style=" margin: 10px;" width = 500 height = 300>
<img src="C:/Users/17363/AppData/Roaming/Typora/typora-user-images/image-20240331211012439.png"  style=" margin: 10px;" width = 500 height = 300>
</div>


<img src="C:/Users/17363/AppData/Roaming/Typora/typora-user-images/image-20240331211340376.png"  style=" margin: 10px;" width = 500 height = 300>

## 基本指令系统的操作



* VLSI  现在微程序实现复杂指令 与  简单指令组成的子程序相比 没有多大的区别  --- 控制存储器和主存的速度差缩小
* **复杂指令系统** CISC    - > x86架构  用于 笔记本 台式机
  *  通过增强指令系统的功能，简化了软件，增加了硬件的复杂程度。然而指令复杂了，指令的执行时间必然加长，从而使整个系统的执行时间反而增加，因而在计算机体系结构设计中，**软硬件的功能分配**必须恰当。
* **精简指令系统** RISC    - > ARM架构  用于 手机 平板
  * 采用流水线工作
  * 选取频率最高的一些简单指令
  * 指令长度固定，指令格式种类少，寻址方式种类少
  * 限 制存储器的访问




<div style="display: flex; justify-content: space-between;">
<img src="C:/Users/17363/AppData/Roaming/Typora/typora-user-images/image-20240331212115457.png"  style=" margin: 10px;" width = 500 height = 300>
<img src="C:/Users/17363/AppData/Roaming/Typora/typora-user-images/image-20240331224826553.png"  style=" margin: 10px;" width = 500 height = 300>
</div>




# 中央处理器

## CPU的功能和结构

**CPU功能**

* 指令控制（PC IR）： 完成**取指令**、**分析指令**和**执行指令**的操作，即程序的顺序控制。
* 操作控制（CU）： 一条指令的功能往往是由**若干操作信号**的组合来实现的。CPU管理并产生由内存取出的每条指令的操作信号，把各种操作信号送往相应的部件，从而控制这些部件按指令的要求进行动作。
* 时间控制（CU）： 对各种操作加以时间上的控制。时间控制要为每条指令按时间顺序**提供应有的控制信号**。
* 数据加工（ALU）： 对数据进行算术和逻辑运算。
* 中断处理（中断系统）： 对计算机运行过程中出现的**异常情况**和**特殊请求**进行处理。



**运算器和控制器**

<img src="C:/Users/17363/AppData/Roaming/Typora/typora-user-images/image-20240401190049439.png"  style=" margin: 10px;" width = 500 height = 300>



**运算器**

* 算数逻辑单元（ALU）：主要功能是进行算术/逻辑运算
* 通用寄存器组：如AX、BX、CX、DX、SP等，用于存放操作数（包括源操作数、目的操作数及中间结果)和各种地址信息等。`SP`是堆栈指针，用于指示栈顶的地址。
  * 高位 AH BH CH DH
  * 低位 AL BL CL DL
* 专用数据通路方式：根据指令执行过程中的数据和地址的流动方向安排链接线路   
  * 多路选择器
  * 三态门

* 单总线方式:将所有寄存器的输入端和输出端都连接到一条公共的通路上。

<div style="display: flex; justify-content: space-between;">
<img src="C:/Users/17363/AppData/Roaming/Typora/typora-user-images/image-20240401191820346.png"  style=" margin: 10px;" width = 500 height = 300>
<img src="C:/Users/17363/AppData/Roaming/Typora/typora-user-images/image-20240401194253702.png"  style=" margin: 10px;" width = 500 height = 300>
</div>


**控制器**

<div style="display: flex; justify-content: space-between;">
<img src="C:/Users/17363/AppData/Roaming/Typora/typora-user-images/image-20240401194805353.png"  style=" margin: 10px;" width = 500 height = 300>
<img src="C:/Users/17363/AppData/Roaming/Typora/typora-user-images/image-20240401194853841.png"  style=" margin: 10px;" width = 500 height = 300>
</div>



## 指令执行过程

> **==指令周期==**：CPU从主存中每取出并执行一条指令所需的**全部时间**


<div style="display: flex; justify-content: space-between;">
<img src="C:/Users/17363/AppData/Roaming/Typora/typora-user-images/image-20240401195456895.png"  style=" margin: 10px;" width = 500 height = 300>
<img src="C:/Users/17363/AppData/Roaming/Typora/typora-user-images/image-20240401195919180.png"  style=" margin: 10px;" width = 500 height = 300>
</div>


<div style="display: flex; justify-content: space-between;">
<img src="C:/Users/17363/AppData/Roaming/Typora/typora-user-images/image-20240401204919005.png"  style=" margin: 10px;" width = 500 height = 300>
<img src="C:/Users/17363/AppData/Roaming/Typora/typora-user-images/image-20240401205117704.png"  style=" margin: 10px;" width = 500 height = 300>
</div>


**指令周期的数据流**

**取指周期**
<img src="C:/Users/17363/AppData/Roaming/Typora/typora-user-images/image-20240401205511303.png"  style=" margin: 10px;" width = 500 height = 300>

**间址周期**
<img src="C:/Users/17363/AppData/Roaming/Typora/typora-user-images/image-20240401210913225.png"  style=" margin: 10px;" width = 500 height = 300>

**执行周期**

* 执行周期的任务是根据IR中的指令字的操作码和操作数通过ALU操作产生执行结果。不同指令的执行周期操作不同，因此没有统一的数据流向

**中断周期**

* 暂停当前任务去完成其他任务。为了能够恢复当前任务，需要保存断点。
<img src="C:/Users/17363/AppData/Roaming/Typora/typora-user-images/image-20240401212456351.png"  style=" margin: 10px;" width = 500 height = 300>



***

**指令执行方案**

* 单指令周期
* 多指令周期

<img src="C:/Users/17363/AppData/Roaming/Typora/typora-user-images/image-20240401213110396.png"  style=" margin: 10px;" width = 500 height = 300>



## 数据通路

### **cpu内部单/双总线方式**

<img src="C:/Users/17363/AppData/Roaming/Typora/typora-user-images/image-20240401215534478.png"  style=" margin: 10px;" width = 500 height = 300>

**例题**

ADD  (R0)，R1   `()表示间接寻址`

分析： ((R0)) +(R1) -> (R0)

取指周期、间址周期、执行周期

1. 取指周期
	<img src="C:/Users/17363/AppData/Roaming/Typora/typora-user-images/image-20240401220931741.png"  style=" margin: 10px;" width = 500 height = 300>
2. 间址周期
	<img src="C:/Users/17363/AppData/Roaming/Typora/typora-user-images/image-20240401220956761.png"  style=" margin: 10px;" width = 500 height = 300>
3. 执行周期
	<img src="C:/Users/17363/AppData/Roaming/Typora/typora-user-images/image-20240401221013745.png"  style=" margin: 10px;" width = 500 height = 300>
	

***

### **专用数据通路**

多路选择器和三态门

<img src="C:/Users/17363/AppData/Roaming/Typora/typora-user-images/image-20240404132242402.png"  style=" margin: 10px;" width = 500 height = 300>


## 控制器

### **硬布线控制器**

> 特点：
>
> * 指令越多，设计和实现就越复杂，因此一般用于**RISC**（精简指令集系统)
> * 如果扩充一条新的指令，则控制器的设计就需要大改，因此扩充指令较困难。
> * 由于使用纯硬件实现控制，因此执行速度很快。微操作控制信号由组合逻辑电路即时产生。

<div style="display: flex; justify-content: space-between;">
<img src="C:/Users/17363/AppData/Roaming/Typora/typora-user-images/image-20240404134342779.png"  style=" margin: 10px;" width = 500 height = 300>
<img src="C:/Users/17363/AppData/Roaming/Typora/typora-user-images/image-20240404134928428.png"  style=" margin: 10px;" width = 500 height = 300>
</div>
***

**硬布线控制器的设计**

1. 分析每个阶段的微操作序列
     <img src="C:/Users/17363/AppData/Roaming/Typora/typora-user-images/image-20240404135751709.png"  style=" margin: 10px;" width = 500 height = 300>
2. 选择CPU的控制方式
     假设采用同步控制方式（定长机器周期）,一个机器周期内安排3个节拍。
3. 安排微操作时序
	<div style="display: flex; justify-content: space-between;">
	<img src="C:/Users/17363/AppData/Roaming/Typora/typora-user-images/image-20240404140153850.png"  style=" margin: 10px;" width = 500 height = 300>
	<img src="C:/Users/17363/AppData/Roaming/Typora/typora-user-images/image-20240404140450788.png"  style=" margin: 10px;" width = 500 height = 300>
	</div>

4. 电路设计
     1. 列出时间操作表
		<div style="display: flex; justify-content: space-between;">
		<img src="C:/Users/17363/AppData/Roaming/Typora/typora-user-images/image-20240404140852036.png"  style=" margin: 10px;" width = 500 height = 300>
		<img src="C:/Users/17363/AppData/Roaming/Typora/typora-user-images/image-20240404141111096.png"  style=" margin: 10px;" width = 500 height = 300>		</div>
	2. 写出微操作命令的最那表达式
		<img src="C:/Users/17363/AppData/Roaming/Typora/typora-user-images/image-20240404141159990.png"  style=" margin: 10px;" width = 500 height = 300>
	3. 画出逻辑图



### 微程序控制器

* 微命令  所需要发出的有效信号       PC~out~、MAR~in~等等
* 微操作  工作要完成什么样的功能   (PC) -> MAR
* 微指令  是对指令执行步骤的描述    完成微操作1,5
* 微程序  由微指令序列组成，每一种==指令==对应一个微程序
* 指令     是对程序执行步骤的描述
* 程序     由指令序列组成
* 微周期  从控制器存储器取出一条微指令并执行相应微操作所需的时间
* 指令周期  从主存取出并执行一条机器指令所需的时间

>一个节拍内可以==并行==完成多个**“相容的”**微操作
>
>**微指令**和**微操作**一一对应，**微指令**中可能包含多个**微命令**
>
>指令是对微指令功能的“封装”

**微指令的基本格式**    操作控制（执行哪几个微操作） + 顺序控制（指明下一条微指令的地址）



**微程序控制器的基本结构**（CU）

* 为地址形成部件
* 顺序逻辑
* CMAR(μPC)
* 地址译码器
* 控制存储器 CM
* CMDR(μIR)

<img src="C:/Users/17363/AppData/Roaming/Typora/typora-user-images/image-20240404154909462.png"  style=" margin: 10px;" width = 500 height = 300>

**微程序控制器的工作原理**

* 取指周期、间址周期、中断周期的微指令序列通常是共用的
* 执行周期的微指令序列各不相同

<div style="display: flex; justify-content: space-between;">
<img src="C:/Users/17363/AppData/Roaming/Typora/typora-user-images/image-20240404155357112.png"  style=" margin: 10px;" width = 500 height = 300>
<img src="C:/Users/17363/AppData/Roaming/Typora/typora-user-images/image-20240404155821607.png"  style=" margin: 10px;" width = 500 height = 300>
</div>
***

<img src="C:/Users/17363/AppData/Roaming/Typora/typora-user-images/image-20240404172821084.png"  style=" margin: 10px;" width = 500 height = 300>


## 微指令的设计

### **格式**

* 水平型
* 垂直型
* 混合型
  * 在垂直型的基础上增加一些不太复杂的并行操作。
  * 微指令较短，仍便于编写；微程序也不长，执行速度加快。

相容性微命令：可以并行完成的
<img src="C:/Users/17363/AppData/Roaming/Typora/typora-user-images/image-20240404161107718.png"  style=" margin: 10px;" width = 500 height = 300>

### **编码方式**

> 微指令的编码方式又称为微指令的控制方式，它是指如何对微指令的控制字段进行编码，以形成控制信号。编码的目标是在保证速度的情况下，尽量缩短微指令字长。

水平型微指令

* 直接编码
  <img src="C:/Users/17363/AppData/Roaming/Typora/typora-user-images/image-20240404163129681.png"  style=" margin: 10px;" width = 500 height = 300>
* 字段直接编码 
  * 互斥类分到同一个段内，相容性微命令分在不同段内 
  * 留出一个状态表示==不操作==
    <img src="C:/Users/17363/AppData/Roaming/Typora/typora-user-images/image-20240404163427869.png"  style=" margin: 10px;" width = 500 height = 300>

* 字短间接编码
    <img src="C:/Users/17363/AppData/Roaming/Typora/typora-user-images/image-20240404164214958.png"  style=" margin: 10px;" width = 500 height = 300>

### 的地址形成方式

<div style="display: flex; justify-content: space-between;">
<img src="C:/Users/17363/AppData/Roaming/Typora/typora-user-images/image-20240404164833224.png"  style=" margin: 10px;" width = 500 height = 300>
<img src="C:/Users/17363/AppData/Roaming/Typora/typora-user-images/image-20240404165132391.png"  style=" margin: 10px;" width = 500 height = 300>
</div>


### 控制单元的设计

* 分析每个阶段的微操作序列
	<img src="C:/Users/17363/AppData/Roaming/Typora/typora-user-images/image-20240404170233517.png" alt="image-20240404170233517" style="zoom:25%;" />
* 写出对应机器指令的微操作命令即节拍安排
  * 每条微指令结束后都需要将`下地址`信息 写入CMAR
  * 在**取指周期**的最后一条微命令完成后，要根据指令操作码确定其**执行周期**的微程序**首地址**
	<img src="C:/Users/17363/AppData/Roaming/Typora/typora-user-images/image-20240404171059969.png" alt="image-20240404171059969" style="zoom:25%;" />

* 确定微指令格式
  * 操作码 +下地址
  * 根据微操作个数决定采用何种**编码方式**，以确定微指令的操作控制字段的位数。
  * 根据CM中存储的微指令总数，确定微指令的顺序控制**字段的位数**。
  * 最后按操作控制字段位数和顺序控制字段位数就可确定微指令字长。

* 编写微指令码点 
  * 根据操作控制字段每一位代表的微操作命令，编写每一条微指令的码点。



### 设计分类
<img src="C:/Users/17363/AppData/Roaming/Typora/typora-user-images/image-20240404172706284.png"  style=" margin: 10px;" width = 500 height = 300>

<img src="C:/Users/17363/AppData/Roaming/Typora/typora-user-images/image-20240404173158486.png"  style=" margin: 10px;" width = 500 height = 300>



## 异常和中断

**异常**：cpu**内部产生**的意外事件，又称为**==内中断==**

与CPU正在执行的指令相关的同步事件

* 故障 
  * 非法操作码，除数为0
* 自限
  * 人为设置，系统调用、TNE等
* 终止 （硬件异常）
  * 控制器出错，存储器出错

**中断**：cpu**外部设备**向cpu发出的中断请求，又称**==外中断==**

与CPU正在执行的指令无关的异步事件

* 可屏蔽中断：通过INTR请求线向CPU发出的中断请求
* 不可屏蔽中断：通过NMI请求线向CPU发出中断请求

**处理过程：**如果CPU**执行指令时**检测到==异常事件==，或者**完成指令执行后**发 现==中断请求信号==，打断**当前用户程序**，若能解决 回到用户程序 ，否则终止



## 指令流水线 

### 流水线的时空图

长度尽量一致，有利于简化取指令和指令译码操作 – 格式少，且源寄存器位置相同，有利于在指令未知时 就可取操作数 – Load/Store指令才能访问存储器，有利于减少操作步 骤，规整流水线 – 内存中“对齐”存放，有利于减少访存次数和流水线 的规整	

### 向量处理机





# 总线系统

## 总线概述

> 一根总线可能有很多信号线
>
> 同一时刻只能有一个部件发送数据，但是可以有多个部件接受数据

**定义**

​		总线是一组能为多个部件**分时共享**的公共信息传送链路



**按链接部件分类**
<img src="C:/Users/17363/AppData/Roaming/Typora/typora-user-images/image-20240418084227121.png"  style=" margin: 10px;" width = 500 height = 300>

* **内部**总线（片内总选）-> 芯片内部的总线（CPU与寄存器）
* **系统**总线（板级总线，板件总线）-> 计算机系统内各功能部件（CPU、主存、i/o接口）
  * 数据总线(DB)：**双向**、数据总线的宽度（位数），与**机器字长**和**存储字长**有关
  * 地址总线(AB)：**单向**（CPU指明地址）、位数与**主存地址空间**及设备数量有关
  * 控制总线(CB)：控制总线传输的是**控制信息**，包括CPU送出的控制命令和主存(或外设）返回CPU的反馈信号。

* **通讯**总线 -> 按数据传输格式（并行-多个数据，串行-单个数据）
  <img src="C:/Users/17363/AppData/Roaming/Typora/typora-user-images/image-20240418083153870.png"  style=" margin: 10px;" width = 500 height = 300>

总线协议

**总线的特性**

* 物理特性：尺寸，形状，管脚数，总线根数等
* 功能特性：描述总线中每一根线的功能（地址，数据，控制）
* 电气特性：定义每一根线上信号的传递方向及有效电平范围
* 时间特性：信号的时序关系



**总线的标准化**

* ISA总线
* EISA总线
* PCI（peripheral Component Interconnect）总线
* PCIe：PCI升级版本，采用点对点的通讯，提高了更高的速度和更大的带宽
* USB：广发用于外围设备，键盘、鼠标和存储设备，以串行方式传输数据
* SATA：链接存储设备，如硬盘和固态驱动器，也是一种串行传输的接口
* IEEE 1394：用于视频设备，提供高数数据传输



**总线的性能指标**

* 总线的传输周期（总线周期）
  * 一次总线操作所需的时间(包括**申请阶段（仲裁）**、**寻址阶段**、**传输阶段**和**结束阶段**（释放总线的使用权））
  * 通常由若干个总线时钟周期构成（可以一对多，一对一，也可以多对一）

* 总线的时钟周期
  * 即机器的时钟周期。计算机有一个统一的时钟，以控制整个计算机的各个部件，总线也要受此时钟的控制。
  * 3.0Ghz    时钟周期为 1/ 3×10^9^s   ns纳秒级
* 总线的工作频率
  * 总线上各种操作的频率，为**总线周期的倒数**
  * 若总线周期=N个时钟周期，则总线的工作频率=时钟频率/N
  * 实际上指**一秒内传送几次数据**
* 总线的时钟频率
  * 即机器的时钟频率，为时钟周期的倒数
  * 若时钟周期为T，则时钟频率为1/T
  * 实际上指**一秒内有多少个时钟周期**
* 总线宽度
  * 又称为**总线位宽**,它是总线上同时能够传输的数据位数
  * 通常是指**数据总线**的根数，如32根称为32位( bit）总线

* 总线带宽

  * 总线的数据传输率，总线在**单位时间可以传输的数据的位数**，单位（B/s）

  * 受到总线宽度，总线驱动器性能，
  * `总线带宽=总线工作频率×总线宽度(bit/s）=总线工作频率×(总线宽度/8)（B/s）= 总线宽度 / 总线周期(bit/s)`
  <img src="C:/Users/17363/AppData/Roaming/Typora/typora-user-images/image-20240418092614334.png"  style=" margin: 10px;" width = 500 height = 300>

* 总线复用
  * 总线复用是指一种信号线在**不同的时间传输不同的信息**。可以使用较少的线传输更多的信息，从而节省了空间和成本

* 信号线数
  * 地址总线、数据总线和控制总线3种总线数的总和称为信号线数




**系统总线的结构（总线的链接方式）**  选择题

* 单总线结构
  <img src="C:/Users/17363/AppData/Roaming/Typora/typora-user-images/image-20240418084514962.png"  style=" margin: 10px;" width = 500 height = 300>
* 双总线结构
  <img src="C:/Users/17363/AppData/Roaming/Typora/typora-user-images/image-20240418084741789.png"  style=" margin: 10px;" width = 500 height = 300>
* 三总线结构
  <img src="C:/Users/17363/AppData/Roaming/Typora/typora-user-images/image-20240418085021597.png"  style=" margin: 10px;" width = 500 height = 300>
* 四总线结构
  <img src="C:/Users/17363/AppData/Roaming/Typora/typora-user-images/image-20240418085312330.png"  style=" margin: 10px;" width = 500 height = 300>






总线的内部结构

总线的设计要素

* 信号线的类型
  * 专用信号线
  * 复用信号线
* 仲裁方式 决定哪个总线主设备将在下次得到总线使用权
* ![image-20240418093303969](C:/Users/17363/AppData/Roaming/Typora/typora-user-images/image-20240418093303969.png)
  
  * 总线仲裁信号
    * 总线请求线  
    * 总线授权线
  * 总线仲裁方式
    * 集中式
      * 链式查询方式
      * <img src="C:/Users/17363/AppData/Roaming/Typora/typora-user-images/image-20240418093753602.png"  style=" margin: 10px;" width = 500 height = 300>
      * 计数器定时查询方式
      * <img src="C:/Users/17363/AppData/Roaming/Typora/typora-user-images/image-20240418094201796.png"  style=" margin: 10px;" width = 500 height = 300>
       	  	   	  * 独立请求方法
    * 分布式  
      * 自举分布式仲裁
      * 冲突检测分布式仲裁
  * 因素平衡
    * 优先级
    * 公平性
      * 优先级带预算
      * 轮询与优先级结合
      * 时段保证
      * 动态优先级调整
      * 权重公平排队
* 定时方式
  * 同步定时
  * 异步定时

* 事务类型
* 总线带宽





# I/O系统的性能

**性能指标**

* 吞吐率

* 响应时间



交互方式分类

* 人机交互
* 机器可读

